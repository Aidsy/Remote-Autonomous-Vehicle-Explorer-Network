
AVRASM ver. 2.1.30  D:\p_bko\BL_active\17a_18a_i2c-my_homepage\17a410_ppm_r06\bl-17a.asm Sun Dec 06 21:33:25 2009

D:\p_bko\BL_active\17a_18a_i2c-my_homepage\17a410_ppm_r06\bl-17a.asm(32): Including file 'C:\Programme\Atmel\AVR Tools\AvrAssembler2\Appnotes\m8def.inc'
D:\p_bko\BL_active\17a_18a_i2c-my_homepage\17a410_ppm_r06\bl-17a.asm(33): Including file 'D:\p_bko\BL_active\17a_18a_i2c-my_homepage\17a410_ppm_r06\bl-17a.inc'
                 
                 
                 ;
                 ;Die Benutzung der Software ist mit folgenden Bedingungen verbunden:
                 ;
                 ;1. Da ich alles kostenlos zur Verfügung stelle, gebe ich keinerlei Garantie
                 ;   und übernehme auch keinerlei Haftung für die Folgen der Benutzung.
                 ;
                 ;2. Die Software ist ausschließlich zur privaten Nutzung bestimmt. Ich
                 ;   habe nicht geprüft, ob bei gewerblicher Nutzung irgendwelche Patentrechte
                 ;   verletzt werden oder sonstige rechtliche Einschränkungen vorliegen.
                 ;
                 ;3. Jeder darf Änderungen vornehmen, z.B. um die Funktion seinen Bedürfnissen
                 ;   anzupassen oder zu erweitern. Ich würde mich freuen, wenn ich weiterhin als
                 ;   Co-Autor in den Unterlagen erscheine und mir ein Link zur entprechenden Seite
                 ;   (falls vorhanden) mitgeteilt wird.
                 ;
                 ;4. Auch nach den Änderungen sollen die Software weiterhin frei sein, d.h. kostenlos bleiben.
                 ;
                 ;!! Wer mit den Nutzungbedingungen nicht einverstanden ist, darf die Software nicht nutzen !!
                 ;
                 ; Dezember 2006
                 ; autor: Bernhard Konze
                 ; email: bernhard.konze@versanet.de
                 ;
                 ;**** **** **** **** ****
                 ; Device
                 ;**** **** **** **** ****
                 ;**** **** **** **** ****
                 ; z.Z. Nur für den Kaufregler BL17A-3P mit 16 MHz geeignet
                 ;**** **** **** **** ****
                 ;**** **** **** **** ****
                 .include "m8def.inc"
                 
                 ;***** Created: 2008-11-07 12:39 ******* Source: ATmega8.xml *************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m8def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega8
                 ;* Date              : 2008-11-07
                 ;* Version           : 2.31
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega8
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M8DEF_INC_
                 #define _M8DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega8
                 #pragma AVRPART ADMIN PART_NAME ATmega8
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x93
                 .equ	SIGNATURE_002	= 0x07
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	GICR	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCR	= 0x37
                 .equ	TWCR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUCSR	= 0x34
                 .equ	TCCR0	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	SFIOR	= 0x30
                 .equ	TCCR1A	= 0x2f
                 .equ	TCCR1B	= 0x2e
                 .equ	TCNT1L	= 0x2c
                 .equ	TCNT1H	= 0x2d
                 .equ	OCR1AL	= 0x2a
                 .equ	OCR1AH	= 0x2b
                 .equ	OCR1BL	= 0x28
                 .equ	OCR1BH	= 0x29
                 .equ	ICR1L	= 0x26
                 .equ	ICR1H	= 0x27
                 .equ	TCCR2	= 0x25
                 .equ	TCNT2	= 0x24
                 .equ	OCR2	= 0x23
                 .equ	ASSR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	UBRRH	= 0x20
                 .equ	UCSRC	= 0x20
                 .equ	EEARL	= 0x1e
                 .equ	EEARH	= 0x1f
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PORTC	= 0x15
                 .equ	DDRC	= 0x14
                 .equ	PINC	= 0x13
                 .equ	PORTD	= 0x12
                 .equ	DDRD	= 0x11
                 .equ	PIND	= 0x10
                 .equ	SPDR	= 0x0f
                 .equ	SPSR	= 0x0e
                 .equ	SPCR	= 0x0d
                 .equ	UDR	= 0x0c
                 .equ	UCSRA	= 0x0b
                 .equ	UCSRB	= 0x0a
                 .equ	UBRRL	= 0x09
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCL	= 0x04
                 .equ	ADCH	= 0x05
                 .equ	TWDR	= 0x03
                 .equ	TWAR	= 0x02
                 .equ	TWSR	= 0x01
                 .equ	TWBR	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; SFIOR - Special Function IO Register
                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; GICR - General Interrupt Control Register
                 .equ	GIMSK	= GICR	; For compatibility
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                 
                 ; GIFR - General Interrupt Flag Register
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 .equ	INTF1	= 7	; External Interrupt Flag 1
                 
                 ; MCUCR - MCU Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 
                 ; TCCR0 - Timer/Counter0 Control Register
                 .equ	CS00	= 0	; Clock Select0 bit 0
                 .equ	CS01	= 1	; Clock Select0 bit 1
                 .equ	CS02	= 2	; Clock Select0 bit 2
                 
                 ; TCNT0 - Timer Counter 0
                 .equ	TCNT00	= 0	; Timer Counter 0 bit 0
                 .equ	TCNT01	= 1	; Timer Counter 0 bit 1
                 .equ	TCNT02	= 2	; Timer Counter 0 bit 2
                 .equ	TCNT03	= 3	; Timer Counter 0 bit 3
                 .equ	TCNT04	= 4	; Timer Counter 0 bit 4
                 .equ	TCNT05	= 5	; Timer Counter 0 bit 5
                 .equ	TCNT06	= 6	; Timer Counter 0 bit 6
                 .equ	TCNT07	= 7	; Timer Counter 0 bit 7
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	FOC1B	= 2	; Force Output Compare 1B
                 .equ	FOC1A	= 3	; Force Output Compare 1A
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	CTC1	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                 .equ	OCF2	= 7	; Output Compare Flag 2
                 
                 ; TCCR2 - Timer/Counter2 Control Register
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM21	= 3	; Waveform Generation Mode
                 .equ	CTC2	= WGM21	; For compatibility
                 .equ	COM20	= 4	; Compare Output Mode bit 0
                 .equ	COM21	= 5	; Compare Output Mode bit 1
                 .equ	WGM20	= 6	; Waveform Genration Mode
                 .equ	PWM2	= WGM20	; For compatibility
                 .equ	FOC2	= 7	; Force Output Compare
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2 - Timer/Counter2 Output Compare Register
                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                 
                 
                 ; ***** USART ************************
                 ; UDR - USART I/O Data Register
                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSRA - USART Control and Status Register A
                 .equ	USR	= UCSRA	; For compatibility
                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                 .equ	U2X	= 1	; Double the USART transmission speed
                 .equ	UPE	= 2	; Parity Error
                 .equ	PE	= UPE	; For compatibility
                 .equ	DOR	= 3	; Data overRun
                 .equ	FE	= 4	; Framing Error
                 .equ	UDRE	= 5	; USART Data Register Empty
                 .equ	TXC	= 6	; USART Transmitt Complete
                 .equ	RXC	= 7	; USART Receive Complete
                 
                 ; UCSRB - USART Control and Status Register B
                 .equ	UCR	= UCSRB	; For compatibility
                 .equ	TXB8	= 0	; Transmit Data Bit 8
                 .equ	RXB8	= 1	; Receive Data Bit 8
                 .equ	UCSZ2	= 2	; Character Size
                 .equ	CHR9	= UCSZ2	; For compatibility
                 .equ	TXEN	= 3	; Transmitter Enable
                 .equ	RXEN	= 4	; Receiver Enable
                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSRC - USART Control and Status Register C
                 .equ	UCPOL	= 0	; Clock Polarity
                 .equ	UCSZ0	= 1	; Character Size
                 .equ	UCSZ1	= 2	; Character Size
                 .equ	USBS	= 3	; Stop Bit Select
                 .equ	UPM0	= 4	; Parity Mode Bit 0
                 .equ	UPM1	= 5	; Parity Mode Bit 1
                 .equ	UMSEL	= 6	; USART Mode Select
                 .equ	URSEL	= 7	; Register Select
                 
                 .equ	UBRRHI	= UBRRH	; For compatibility
                 
                 ; ***** TWI **************************
                 ; TWBR - TWI Bit Rate register
                 .equ	I2BR	= TWBR	; For compatibility
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	I2CR	= TWCR	; For compatibility
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	I2IE	= TWIE	; For compatibility
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	I2EN	= TWEN	; For compatibility
                 .equ	ENI2C	= TWEN	; For compatibility
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	I2WC	= TWWC	; For compatibility
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	I2STO	= TWSTO	; For compatibility
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	I2STA	= TWSTA	; For compatibility
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	I2EA	= TWEA	; For compatibility
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 .equ	I2INT	= TWINT	; For compatibility
                 
                 ; TWSR - TWI Status Register
                 .equ	I2SR	= TWSR	; For compatibility
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWS0	= TWPS0	; For compatibility
                 .equ	I2GCE	= TWPS0	; For compatibility
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS1	= TWPS1	; For compatibility
                 .equ	TWS3	= 3	; TWI Status
                 .equ	I2S3	= TWS3	; For compatibility
                 .equ	TWS4	= 4	; TWI Status
                 .equ	I2S4	= TWS4	; For compatibility
                 .equ	TWS5	= 5	; TWI Status
                 .equ	I2S5	= TWS5	; For compatibility
                 .equ	TWS6	= 6	; TWI Status
                 .equ	I2S6	= TWS6	; For compatibility
                 .equ	TWS7	= 7	; TWI Status
                 .equ	I2S7	= TWS7	; For compatibility
                 
                 ; TWDR - TWI Data register
                 .equ	I2DR	= TWDR	; For compatibility
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	I2AR	= TWAR	; For compatibility
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EEWEE	= EEMWE	; For compatibility
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 .equ	SM0	= 4	; Sleep Mode Select
                 .equ	SM1	= 5	; Sleep Mode Select
                 .equ	SM2	= 6	; Sleep Mode Select
                 .equ	SE	= 7	; Sleep Enable
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	MCUSR	= MCUCSR	; For compatibility
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; SPMCR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write Section Read Enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PUD	= 2	; Pull-up Disable
                 .equ	ADHSM	= 4	; ADC High Speed Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADCSR	= ADCSRA	; For compatibility
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADFR	= 5	; ADC  Free Running Select
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	BODEN	= 6	; Brown out detector enable
                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	CKOPT	= 4	; Oscillator Options
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	WTDON	= 6	; Enable watchdog
                 .equ	RSTDISBL	= 7	; Disable reset
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 1024
                 .equ	RAMEND	= 0x045f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x01ff
                 .equ	EEPROMEND	= 0x01ff
                 .equ	EEADRBITS	= 9
                 #pragma AVRPART MEMORY PROG_FLASH 8192
                 #pragma AVRPART MEMORY EEPROM 512
                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0xc00
                 .equ	NRWW_STOP_ADDR	= 0xfff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0xbff
                 .equ	PAGESIZE	= 32
                 .equ	FIRSTBOOTSTART	= 0xf80
                 .equ	SECONDBOOTSTART	= 0xf00
                 .equ	THIRDBOOTSTART	= 0xe00
                 .equ	FOURTHBOOTSTART	= 0xc00
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                 .equ	OC2addr	= 0x0003	; Timer/Counter2 Compare Match
                 .equ	OVF2addr	= 0x0004	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0005	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0006	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0007	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x0008	; Timer/Counter1 Overflow
                 .equ	OVF0addr	= 0x0009	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x000a	; Serial Transfer Complete
                 .equ	URXCaddr	= 0x000b	; USART, Rx Complete
                 .equ	UDREaddr	= 0x000c	; USART Data Register Empty
                 .equ	UTXCaddr	= 0x000d	; USART, Tx Complete
                 .equ	ADCCaddr	= 0x000e	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x000f	; EEPROM Ready
                 .equ	ACIaddr	= 0x0010	; Analog Comparator
                 .equ	TWIaddr	= 0x0011	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0012	; Store Program Memory Ready
                 
                 .equ	INT_VECTORS_SIZE	= 19	; size in words
                 
                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                 
                 #endif  /* _M8DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 .include "bl-17a.inc"
                 
                 ;* BL-17A                                                  *
                 ;* Dez.2006
                 ;* http://home.versanet.de/~b-konze/                       *
                 ;*********************************************************** 
                 
                 #define Typ "bl-17a"
                 
                 ; activate Motor brake 
                 
                 .equ MOT_BRAKE      = 0
                 
                 ;Select Brake Power
                 ;	1 = min Brake
                 ;	2 = medium Brake
                 ;  	3 = hard Brake
                 
                 .equ BrakeSelect    = 2
                 
                 .equ CALIBRATE			= 1      
                 .equ OSCAL_VALUE		= 0x01ff 	; eeprom position
                 
                 .equ FORCE_LIPO 	= 1			; 1=Lipo und 0=NC wenn keine Buecke
                 .equ ActiveFreeRun	= 0
                 
                 ;**** **** **** **** ****
                 ; PORT  definitions
                 ;**** **** **** **** ****
                 
                 ;*********************
                 ; PORT D 
                 ;*********************  
                 .equ	BpFET		= 7	;o
                 .equ	c_comp		= 6	;i common comparator input (AIN0)
                 .equ	ApFET		= 5	;o
                 .equ	CpFET		= 4	;o
                 .equ	CnFET		= 3	;o
                 .equ	rcp_in		= 2	;i r/c pulse input
                 .equ	BnFET		= 1	;o
                 .equ	AnFET		= 0	;o
                 .equ	INIT_PD		= 0
                 
                 .equ	DIR_PD		= (1<<ApFET)+(1<<BpFET)+(1<<CpFET)+(1<<AnFET)+(1<<BnFET)+(1<<CnFET)
                 .equ	BRAKE_PD	= (1<<AnFET)+(1<<BnFET)+(1<<CnFET)
                 
                 #define ApFET_on	sbi	PORTD,5
                 #define ApFET_off	cbi	PORTD,5
                 #define BpFET_on	sbi	PORTD,7
                 #define BpFET_off	cbi	PORTD,7
                 #define CpFET_on	sbi	PORTD,4
                 #define CpFET_off	cbi	PORTD,4
                 #define AnFET_on	sbi	PORTD,0
                 #define AnFET_off	cbi	PORTD,0
                 #define BnFET_on	sbi	PORTD,1
                 #define BnFET_off	cbi	PORTD,1
                 #define CnFET_on	sbi	PORTD,3
                 #define CnFET_off	cbi	PORTD,3
                 
                 
                 ;*********************
                 ; PORT C definitions *
                 ;*********************
                 ;.equ			= 0	; ADC0
                 .;equ    	  	= 1	; ADC1
                 .equ	mux_a		= 2	; ADC2 phase input
                 .equ    mux_b   	= 3     ; ADC3 phase input 
                 .equ	mux_c		= 4	; ADC4 phase input
                 ;.equ    	  	= 5	; ADC5
                 
                 ;*********************
                 ; ADC only
                 ;*********************
                 ;.equ    	  	= 6	; ADC6
                 .equ 	ACCU_MUX	= 7 	; ADC7 voltage control input 
                 
                 .equ	INIT_PC		= 0
                 .equ	DIR_PC		= 0
                 .equ	BRAKE_PC	= 0
                 
                 
                 ;*********************
                 ; PORT B definitions *
                 ;*********************
                 ;.equ		= 7	
                 ;.equ		= 6	
                 ;.equ		= 5    	(sck stk200 interface) 
                 ;.equ		= 4	(miso stk200 interface)
                 ;.equ		= 3	(mosi stk200 interface) 
                 ;.equ		= 2	
                 ;.equ		= 1	
                 ;.equ		= 0	; connected with pb4 ???	
                 
                 .equ	INIT_PB		= 0
                 .equ	DIR_PB		= 0
                 .equ	BRAKE_PB	= 0
                 
                 ;
                 ; 8K Bytes of In-System Self-Programmable Flash
                 ; 512 Bytes EEPROM
                 ; 1K Byte Internal SRAM
                 ;**** **** **** **** ****
                 ;**** **** **** **** ****
                 ; fuses must be set to internal calibrated oscillator = 8 mhz
                 ;**** **** **** **** ****
                 ;**** **** **** **** ****
                 
                 ;.equ MOT_BRAKE    = 0
                 
                 .equ RANGE533MS	= 0
                 
                 .if RANGE533MS == 1
                 .else
                 	.equ	MIN_RC_PULS = 1100*2	; µs (or lower) = NO_POWER
                 .endif	; RANGE533MS == 1
                 
                 .equ	CHANGE_TIMEOUT	= 0x01
                 .equ	CHANGE_TOT_LOW	= 0x01
                 
                 .equ	POWER_RANGE	= 200			; full range of tcnt0 setting
                 .equ	MIN_DUTY	= 30			; no power
                 .equ	NO_POWER	= 256-MIN_DUTY		; (POWER_OFF)
                 .equ	MAX_POWER	= 256-POWER_RANGE	; (FULL_POWER)
                 
                 .equ	PWR_MAX_RPM1	= POWER_RANGE/4
                 .equ	PWR_MAX_RPM2	= POWER_RANGE/2
                 
                 .equ	PWR_STARTUP	= MIN_DUTY
                 .equ	PWR_MAX_STARTUP	= MIN_DUTY+5
                 
                 .equ	timeoutSTART	= 65000
                 .equ	timeoutMIN	= 48000
                 
                 .equ	T1STOP	= 0x00
                 .equ	T1CK8	= 0x02
                 
                 .equ	EXT0_DIS	= 0x00	; disable ext0int
                 .equ	EXT0_EN		= 0x40	; enable ext0int
                 
                 .equ	PWR_RANGE1	= 0x80	; ( ~2400 RPM )
                 .equ	PWR_RANGE2	= 0x40	; ( ~4800 RPM )
                 
                 .equ	ENOUGH_GOODIES	= 60
                 
                 ;**** **** **** **** ****
                 ; Register Definitions
                 .def	i_sreg		 = r1	; status register save in interrupts
                 .def	tcnt0_power_on	 = r2	; timer0 counts nFETs are switched on
                 .def	tcnt0_change_tot = r3	; when zero, tcnt0_power_on is changed by one (inc or dec)
                 ;.def	...	 	 = r4	; upper 8bit timer1 (software-) register
                 .def	uart_cnt	 = r5
                 .def	tcnt0_pwron_next = r6
                 
                 .def	start_rcpuls_l	 = r7
                 .def	start_rcpuls_h	 = r8
                 .def	motor_count 	 = r9
                 ;.def			 = r10
                 .def	control_timeout	 = r11
                 .equ	CONTROL_TOT	 = 100	; time = NUMBER x 32ms
                 
                 .def	current_err	 = r12	; counts consecutive current errors
                 .equ	CURRENT_ERR_MAX  = 3	; performs a reset after MAX errors
                 
                 .def	sys_control	 = r13
                 .def	t1_timeout	 = r14
                 .def	run_control	 = r15
                 
                 
                 .def	temp1	= r16			; main temporary
                 .def	temp2	= r17			; main temporary
                 .def	temp3	= r18			; main temporary
                 .def	temp4	= r19			; main temporary
                 
                 .def	i_temp1	= r20			; interrupt temporary
                 .def	i_temp2	= r21			; interrupt temporary
                 .def	i_temp3	= r22			; interrupt temporary
                 
                 .def	flags0	= r23	; state flags
                 	.equ	OCT1_PENDING	= 0	; if set, output compare interrunpt is pending
                 	.equ	UB_LOW 		= 1	; set if accu voltage low
                 	.equ	I_pFET_HIGH	= 2	; set if over-current detect
                 	.equ	GET_STATE	= 3	; set if state is to be send
                 	.equ	C_FET		= 4	; if set, C-FET state is to be changed
                 	.equ	A_FET		= 5	; if set, A-FET state is to be changed
                 	     ; if neither 1 nor 2 is set, B-FET state is to be changed
                 	.equ	I_OFF_CYCLE	= 6	; if set, current off cycle is active
                 	.equ	T1OVFL_FLAG	= 7	; each timer1 overflow sets this flag - used for voltage + current watch
                 
                 .def	flags1	= r24	; state flags
                 	.equ	POWER_OFF	= 0	; switch fets on disabled
                 	.equ	FULL_POWER	= 1	; 100% on - don't switch off, but do OFF_CYCLE working
                 	.equ	CALC_NEXT_OCT1	= 2	; calculate OCT1 offset, when wait_OCT1_before_switch is called
                 	.equ	RC_PULS_UPDATED	= 3	; new rc-puls value available
                 	.equ	EVAL_RC_PULS	= 4	; if set, new rc puls is evaluated, while waiting for OCT1
                 	.equ	EVAL_SYS_STATE	= 5	; if set, overcurrent and undervoltage are checked
                 	.equ	EVAL_RPM	= 6	; if set, next PWM on should look for current
                 	.equ	EVAL_PWM	= 7	; if set, PWM should be updated
                 
                 .def	flags2	= r25
                 	.equ	RPM_RANGE1	= 0	; if set RPM is lower than 1831 RPM
                 	.equ	RPM_RANGE2	= 1	; if set RPM is between 1831 RPM and 3662 RPM
                 	.equ	SCAN_TIMEOUT	= 2	; if set a startup timeout occurred
                 	.equ	POFF_CYCLE	= 3	; if set one commutation cycle is performed without power
                 	.equ	COMP_SAVE	= 4	; if set ACO was high
                 	.equ	STARTUP		= 5	; if set startup-phase is active
                 	.equ	RC_INTERVAL_OK	= 6	; 
                 	.equ	NO_SYNC		= 7	; 
                 
                 ; here the XYZ registers are placed ( r26-r31)
                 
                 ; ZH = new_duty		; PWM destination
                 
                 
                 ;**** **** **** **** ****
                 ; RAM Definitions
                 .dseg					;EEPROM segment
                 .org SRAM_START
                 
000060           tcnt1_sav_l:	.byte	1	; actual timer1 value
000061           tcnt1_sav_h:	.byte	1
000062           last_tcnt1_l:	.byte	1	; last timer1 value
000063           last_tcnt1_h:	.byte	1
000064           timing_l:	.byte	1	; holds time of 4 commutations 
000065           timing_h:	.byte	1
000066           timing_x:	.byte	1
                 
000067           timing_acc_l:	.byte	1	; holds the average time of 4 commutations 
000068           timing_acc_h:	.byte	1
000069           timing_acc_x:	.byte	1
                 
00006a           rpm_l:		.byte	1	; holds the average time of 4 commutations 
00006b           rpm_h:		.byte	1
00006c           rpm_x:		.byte	1
                 
00006d           wt_comp_scan_l:	.byte	1	; time from switch to comparator scan
00006e           wt_comp_scan_h:	.byte	1       
00006f           com_timing_l:	.byte	1	; time from zero-crossing to switch of the appropriate FET
000070           com_timing_h:	.byte	1
000071           wt_OCT1_tot_l:	.byte	1	; OCT1 waiting time
000072           wt_OCT1_tot_h:	.byte	1
000073           zero_wt_l:	.byte	1
000074           zero_wt_h:	.byte	1
000075           last_com_l:	.byte	1
000076           last_com_h:	.byte	1
                 
000077           stop_rcpuls_l:	.byte	1
000078           stop_rcpuls_h:	.byte	1
000079           new_rcpuls_l:	.byte	1
00007a           new_rcpuls_h:	.byte	1
                 
00007b           duty_offset:	.byte	1
00007c           goodies:	.byte	1
00007d           comp_state:	.byte	1
00007e           uart_command:	.byte	1
                 
00007f           uart_data:	.byte	100		; only for debug requirements
                 
                 
                 ;**** **** **** **** ****
                 ; ATmega8 interrupts
                 
                 ;.equ	INT0addr=$001	; External Interrupt0 Vector Address
                 ;.equ	INT1addr=$002	; External Interrupt1 Vector Address
                 ;.equ	OC2addr =$003	; Output Compare2 Interrupt Vector Address
                 ;.equ	OVF2addr=$004	; Overflow2 Interrupt Vector Address
                 ;.equ	ICP1addr=$005	; Input Capture1 Interrupt Vector Address
                 ;.equ	OC1Aaddr=$006	; Output Compare1A Interrupt Vector Address
                 ;.equ	OC1Baddr=$007	; Output Compare1B Interrupt Vector Address
                 ;.equ	OVF1addr=$008	; Overflow1 Interrupt Vector Address
                 ;.equ	OVF0addr=$009	; Overflow0 Interrupt Vector Address
                 ;.equ	SPIaddr =$00a	; SPI Interrupt Vector Address
                 ;.equ	URXCaddr=$00b	; USART Receive Complete Interrupt Vector Address
                 ;.equ	UDREaddr=$00c	; USART Data Register Empty Interrupt Vector Address
                 ;.equ	UTXCaddr=$00d	; USART Transmit Complete Interrupt Vector Address
                 ;.equ	ADCCaddr=$00e	; ADC Interrupt Vector Address
                 ;.equ	ERDYaddr=$00f	; EEPROM Interrupt Vector Address
                 ;.equ	ACIaddr =$010	; Analog Comparator Interrupt Vector Address
                 ;.equ	TWIaddr =$011	; Irq. vector address for Two-Wire Interface
                 ;.equ	SPMaddr =$012	; SPM complete Interrupt Vector Address
                 ;.equ	SPMRaddr =$012	; SPM complete Interrupt Vector Address
                 ;-----bko-----------------------------------------------------------------
                 
                 ;**** **** **** **** ****
                 .cseg
                 .org 0
                 ;**** **** **** **** ****
                 
                 ;-----bko-----------------------------------------------------------------
                 ; reset and interrupt jump table
000000 c016      		rjmp	reset
000001 c063      		rjmp	ext_int0
000002 0000      		nop	; ext_int1
000003 0000      		nop	; t2oc_int
000004 0000      		nop	; t2ovfl_int
000005 0000      		nop	; icp1
000006 c0a6      		rjmp	t1oca_int
000007 0000      		nop	; t1ocb_int
000008 c0a8      		rjmp	t1ovfl_int
000009 c0b3      		rjmp	t0ovfl_int
00000a 0000      		nop	; spi_int
00000b 0000      		nop	; urxc
00000c 0000      		nop	; udre
00000d 0000      		nop	; utxc
                 ; not used	nop	; adc_int
                 ; not used	nop	; eep_int
                 ; not used	nop	; aci_int
                 ; not used	nop	; wire2_int
                 ; not used	nop	; spmc_int
                 
                 
00000e 0a0d      version:	.db	0x0d, 0x0a
00000f 6b62
000010 6c62
000011 312d
000012 6137
000013 3134
000014 7230
000015 3630      		.db	"bk",Typ,"410r06"
000016 0a0d      		.db	0x0d, 0x0a
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; init after reset
                 
000017 e004      reset:		ldi	temp1, high(RAMEND)	; stack = RAMEND
000018 bf0e      		out	SPH, temp1
000019 e50f      		ldi	temp1, low(RAMEND)
00001a bf0d      		out 	SPL, temp1
                 
                 	; runs with 16MHz crystal - no calibration needed
                 
                 	; portB
00001b e000      		ldi	temp1, INIT_PB
00001c bb08      		out	PORTB, temp1
00001d e000      		ldi	temp1, DIR_PB
00001e bb07      		out	DDRB, temp1
                 
                 	; portC
00001f e000      		ldi	temp1, INIT_PC
000020 bb05      		out	PORTC, temp1
000021 e000      		ldi	temp1, DIR_PC
000022 bb04      		out	DDRC, temp1
                 
                 	; portD
000023 e000      		ldi	temp1, INIT_PD
000024 bb02      		out	PORTD, temp1
000025 eb0b      		ldi	temp1, DIR_PD
000026 bb01      		out	DDRD, temp1
                 
                 	; timer0: PWM + beep control = 0x02 	; start timer0 with CK/8 (0.5µs/count)
000027 e002      		ldi	temp1, 0x02
000028 bf03      		out	TCCR0, temp1
                 
                 	; timer1: commutation control = 0x02	; start timer1 with CK/8 (0.5µs/count)
000029 e002      		ldi	temp1, T1CK8
00002a bd0e      		out	TCCR1B, temp1
                 
                 	; reset state flags
00002b 2777      		clr	flags0
00002c 2788      		clr	flags1
00002d 2799      		clr	flags2
                 
                 	; clear RAM
00002e 27bb      		clr	XH
00002f e6a0      		ldi	XL, low (SRAM_START)
000030 2700      		clr	temp1
000031 930d      clear_ram:	st	X+, temp1
000032 38a0      		cpi	XL, uart_data+1
000033 f3e8      		brlo	clear_ram
                 
                 	; power off
000034 d289      		rcall	switch_power_off
                 
                 	; reset rc puls timeout
000035 e604      		ldi	temp1, CONTROL_TOT
000036 2eb0      		mov	control_timeout, temp1
                 		
000037 d0f9      		rcall	wait260ms	; wait a while
000038 d0f8      		rcall	wait260ms
                 
000039 d0cb      		rcall	beep_f1
00003a d0ea      		rcall	wait30ms
00003b d0cc      		rcall	beep_f2
00003c d0e8      		rcall	wait30ms
00003d d0cd      		rcall	beep_f3
00003e d0e6      		rcall	wait30ms
                 
                 control_start:	; init variables
00003f e001      		ldi	temp1, CHANGE_TIMEOUT
000040 2e30      		mov	tcnt0_change_tot, temp1
000041 ee02      		ldi	temp1, NO_POWER
000042 2e20      		mov	tcnt0_power_on, temp1
                 
000043 e000      		ldi	temp1, 0		; reset error counters
000044 2ec0      		mov	current_err,temp1
000045 2ed0      		mov	sys_control, temp1
                 
                 	; init registers and interrupts
000046 e105      		ldi	temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
000047 bf08      		out	TIFR, temp1		; clear TOIE1,OCIE1A & TOIE0
000048 bf09      		out	TIMSK, temp1		; enable TOIE1,OCIE1A & TOIE0 interrupts
                 
000049 9478      		sei				; enable all interrupts
                 
                 ; init rc-puls
00004a e003      		ldi	temp1, (1<<ISC01)+(1<<ISC00)
00004b bf05      		out	MCUCR, temp1		; set next int0 to rising edge
00004c e400      		ldi	temp1, EXT0_EN		; enable ext0int
00004d bf0b      		out	GIMSK, temp1
00004e e02a      i_rc_puls1:	ldi	temp3, 10		; wait for this count of receiving power off
00004f ff83      i_rc_puls2:	sbrs	flags1, RC_PULS_UPDATED
000050 cffe      		rjmp	i_rc_puls2
000051 9100 0079 		lds	temp1, new_rcpuls_l
000053 9110 007a 		lds	temp2, new_rcpuls_h
000055 7f87      		cbr	flags1, (1<<RC_PULS_UPDATED) ; rc impuls value is read out
000056 5908      		subi	temp1, low  (MIN_RC_PULS)	; power off received ?
000057 4018      		sbci	temp2, high (MIN_RC_PULS)
000058 f7a8      		brcc	i_rc_puls1		; no - reset counter
000059 952a      		dec	temp3			; yes - decrement counter
00005a f7a1      		brne	i_rc_puls2		; repeat until zero
00005b 94f8      		cli				; disable all interrupts
00005c d0b1      		rcall	beep_f4			; signal: rcpuls ready
00005d d0b0      		rcall	beep_f4
00005e d0af      		rcall	beep_f4
00005f 9478      		sei				; enable all interrupts
                 
000060 e10e      		ldi	temp1, 30
000061 9300 007b 		sts	duty_offset, temp1
                 
000063 d177      		rcall	set_all_timings
                 
000064 c26f      		rjmp	init_startup
                 		
                 ;-----bko-----------------------------------------------------------------
                 ; external interrupt0 = rc pulse input
000065 b61f      ext_int0:	in	i_sreg, SREG
000066 2744      		clr	i_temp1			; disable extint edge may be changed
000067 bf4b      		out	GIMSK, i_temp1
                 
                 ; evaluate edge of this interrupt
000068 b745      		in	i_temp1, MCUCR
000069 ff40      		sbrs	i_temp1, ISC00
00006a c01d      		rjmp	falling_edge		; bit is clear = falling edge
                 
                 ; should be rising edge - test rc impuls level state for possible jitter
00006b 9b82      		sbis	PIND, rcp_in
00006c c03c      		rjmp	extint1_exit		; jump, if low state
                 
                 ; rc impuls is at high state
00006d e042      		ldi	i_temp1, (1<<ISC01)
00006e bf45      		out	MCUCR, i_temp1		; set next int0 to falling edge
                 
                 ; get timer1 values
00006f b54c      		in	i_temp1, TCNT1L
000070 b55d      		in	i_temp2, TCNT1H
000071 2e74      		mov	start_rcpuls_l, i_temp1
000072 2e85      		mov	start_rcpuls_h, i_temp2
                 ; test rcpulse interval
000073 7b9f      		cbr	flags2, (1<<RC_INTERVAL_OK) ; preset to not ok
000074 9160 0077 		lds	i_temp3, stop_rcpuls_l
000076 1b46      		sub	i_temp1, i_temp3
000077 9160 0078 		lds	i_temp3, stop_rcpuls_h
000079 0b56      		sbc	i_temp2, i_temp3
00007a 3540      		cpi	i_temp1, low (25000*2)
00007b ec63      		ldi	i_temp3, high(25000*2)	; test range high
00007c 0756      		cpc	i_temp2, i_temp3
00007d f430      		brsh	extint1_fail		; through away
00007e 3c48      		cpi	i_temp1, low (100*2)
00007f e060      		ldi	i_temp3, high(100*2)	; test range low
000080 0756      		cpc	i_temp2, i_temp3
000081 f010      		brlo	extint1_fail		; through away
000082 6490      		sbr	flags2, (1<<RC_INTERVAL_OK) ; set to rc impuls value is ok !
000083 c025      		rjmp	extint1_exit
                 
000084 20bb      extint1_fail:	tst	control_timeout
000085 f119      		breq	extint1_exit
000086 94ba      		dec	control_timeout
000087 c021      		rjmp	extint1_exit
                 
                 ; rc impuls is at low state
000088 9982      falling_edge:	sbic	PIND, rcp_in		; test level of rc impuls
000089 c01f      		rjmp	extint1_exit		; seems to be a spike
                 
00008a e043      		ldi	i_temp1, (1<<ISC01)+(1<<ISC00)
00008b bf45      		out	MCUCR, i_temp1		; set next int0 to rising edge
00008c fd83      		sbrc	flags1, RC_PULS_UPDATED
00008d c01b      		rjmp	extint1_exit
                 
                 ; get timer1 values
00008e b54c      		in	i_temp1, TCNT1L
00008f b55d      		in	i_temp2, TCNT1H
000090 9340 0077 		sts	stop_rcpuls_l, i_temp1	; prepare next interval evaluation
000092 9350 0078 		sts	stop_rcpuls_h, i_temp2
                 
000094 ff96      		sbrs	flags2, RC_INTERVAL_OK
000095 c013      		rjmp	extint1_exit
000096 7b9f      		cbr	flags2, (1<<RC_INTERVAL_OK) ; flag is evaluated
                 
000097 1947      		sub	i_temp1, start_rcpuls_l
000098 0958      		sbc	i_temp2, start_rcpuls_h
                 
                 	; save impuls length
000099 9340 0079 		sts	new_rcpuls_l, i_temp1
00009b 9350 007a 		sts	new_rcpuls_h, i_temp2
00009d 3340      		cpi	i_temp1, low (2200*2)
00009e e161      		ldi	i_temp3, high(2200*2)	; test range high
00009f 0756      		cpc	i_temp2, i_temp3
0000a0 f718      		brsh	extint1_fail		; through away
0000a1 3440      		cpi	i_temp1, low (800*2)
0000a2 e066      		ldi	i_temp3, high(800*2)	; test range low
0000a3 0756      		cpc	i_temp2, i_temp3
0000a4 f2f8      		brlo	extint1_fail		; through away
0000a5 6088      		sbr	flags1, (1<<RC_PULS_UPDATED) ; set to rc impuls value is ok !
0000a6 e644      		ldi	i_temp1, CONTROL_TOT
0000a7 2eb4      		mov	control_timeout, i_temp1
0000a8 c000      		rjmp	extint1_exit
                 
                 ; enable int1 again -  also entry for spike detect
0000a9 e450      extint1_exit:	ldi	i_temp2, EXT0_EN
0000aa bf5b      		out	GIMSK, i_temp2
0000ab be1f      		out	SREG, i_sreg
0000ac 9518      		reti
                 ;-----bko-----------------------------------------------------------------
                 ; output compare timer1 interrupt
0000ad b61f      t1oca_int:	in	i_sreg, SREG
0000ae 7f7e      		cbr	flags0, (1<<OCT1_PENDING) ; signal OCT1 passed
0000af be1f      		out	SREG, i_sreg
0000b0 9518      		reti
                 ;-----bko-----------------------------------------------------------------
                 ; overflow timer1 / happens all 32768µs
0000b1 b61f      t1ovfl_int:	in	i_sreg, SREG
0000b2 6870      		sbr	flags0, (1<<T1OVFL_FLAG)
                 
0000b3 20ee      		tst	t1_timeout
0000b4 f009      		breq	t1ovfl_10
0000b5 94ea      		dec	t1_timeout
                 
0000b6 20bb      t1ovfl_10:	tst	control_timeout
0000b7 f411      		brne	t1ovfl_20
0000b8 27ff      		clr	ZH
0000b9 c001      		rjmp	t1ovfl_99
0000ba 94ba      t1ovfl_20:	dec	control_timeout
                 
0000bb be1f      t1ovfl_99:	out	SREG, i_sreg
0000bc 9518      		reti
                 ;-----bko-----------------------------------------------------------------
                 ; timer0 overflow interrupt
0000bd b61f      t0ovfl_int:	in	i_sreg, SREG
0000be fd76      		sbrc	flags0, I_OFF_CYCLE
0000bf c026      		rjmp	t0_on_cycle
                 
0000c0 6190      t0_off_cycle:	sbr	flags2, (1<<COMP_SAVE)
0000c1 9945      		sbic	ACSR, ACO		; mirror inverted ACO to bit-var
0000c2 7e9f      		cbr	flags2, (1<<COMP_SAVE)
                 
                 	; changes in PWM ?
0000c3 2d42      		mov	i_temp1, tcnt0_power_on
0000c4 2d56      		mov	i_temp2, tcnt0_pwron_next
0000c5 1754      		cp	i_temp2, i_temp1
0000c6 f430      		brsh	lower_pwm		; next power-on-time is lower or same
0000c7 943a      higher_pwm:	dec	tcnt0_change_tot	; change-timeout passed ?
0000c8 f459      		brne	nFET_off		; .. no
0000c9 e051      		ldi	i_temp2, CHANGE_TIMEOUT	; .. yes - change-timeout for more power
0000ca 2e35      		mov	tcnt0_change_tot, i_temp2 ; reset change-timeout and decrement
0000cb 954a      		dec	i_temp1			; <dec> increases power-on-time
0000cc c006      		rjmp	set_next_pwm
                 
0000cd f031      lower_pwm:	breq	nFET_off		; pwm is unchanged
0000ce 943a      		dec	tcnt0_change_tot	; change-timeout passed ?
0000cf f421      		brne	nFET_off		; .. no
0000d0 e051      		ldi	i_temp2, CHANGE_TOT_LOW ; .. yes - change-timeout for lower power
0000d1 2e35      		mov	tcnt0_change_tot, i_temp2 ; reset change-timeout and increment
0000d2 9543      		inc	i_temp1			; <inc> decreases power-on-time
                 
0000d3 2e24      set_next_pwm:	mov	tcnt0_power_on, i_temp1
                 
0000d4 6470      nFET_off:	sbr	flags0, (1<<I_OFF_CYCLE) ; PWM state = off cycle
                 
                 	; switch appropriate nFET off
0000d5 ff74      		sbrs	flags0, C_FET
0000d6 c003      		rjmp	test_AnFET
                 
                 ; C_FET is active
0000d7 ff81      		sbrs	flags1, FULL_POWER
0000d8 9893      		CnFET_off		; Cn off
0000d9 c007      		rjmp	reload_t0_off_cycle
                 
0000da ff75      test_AnFET:	sbrs	flags0, A_FET
0000db c003      		rjmp	switch_BnFET
                 
                 ; A_FET is active
0000dc ff81      switch_AnFET:	sbrs	flags1, FULL_POWER
0000dd 9890      		AnFET_off		; An off
0000de c002      		rjmp	reload_t0_off_cycle
                 
                 ; B_FET is active
0000df ff81      switch_BnFET:	sbrs	flags1, FULL_POWER
0000e0 9891      		BnFET_off		; Bn off
                 
                 	; reload timer0 with the appropriate value
                 reload_t0_off_cycle:
0000e1 2d42      		mov	i_temp1, tcnt0_power_on
0000e2 5348      		subi	i_temp1, -POWER_RANGE	; adi i_temp1, POWER_RANGE
0000e3 9540      		com	i_temp1			; timer0 increments
0000e4 bf42      		out	TCNT0, i_temp1
                 
0000e5 c01b      		rjmp	t0_int_exit
                 
                 ; reload timer90 + switch appropriate nFET on
0000e6 2d42      t0_on_cycle:	mov	i_temp1, tcnt0_power_on
0000e7 bf42      		out	TCNT0, i_temp1		; reload t0
0000e8 7b7f      		cbr	flags0, (1<<I_OFF_CYCLE) ; PWM state = on cycle (no off cycle)
                 
                 ; switch appropriate nFET on
0000e9 ff74      nFET_on:	sbrs	flags0, C_FET		; is Cn choppered ?
0000ea c003      		rjmp	test_AnFET_on			; .. no - test An
0000eb ff80      		sbrs	flags1, POWER_OFF
0000ec 9a93      		CnFET_on		; Cn on
0000ed c007      		rjmp	eval_power_state
0000ee ff75      test_AnFET_on:	sbrs	flags0, A_FET		; is An choppered ?
0000ef c003      		rjmp	sw_BnFET_on			; .. no - Bn has to be choppered
0000f0 ff80      		sbrs	flags1, POWER_OFF
0000f1 9a90      		AnFET_on		; An on
0000f2 c002      		rjmp	eval_power_state
0000f3 ff80      sw_BnFET_on:	sbrs	flags1, POWER_OFF
0000f4 9a91      		BnFET_on		; Bn on
                 
                 	; evaluate power state
                 eval_power_state:
0000f5 3349      		cpi	i_temp1, MAX_POWER+1
0000f6 f418      		brsh	not_full_power
                 	; FULL POWER
0000f7 6082      		sbr	flags1, (1<<FULL_POWER)	; tcnt0_power_on = MAX_POWER means FULL_POWER
0000f8 7f8e      		cbr	flags1, (1<<POWER_OFF)
0000f9 c007      		rjmp	t0_int_exit
0000fa 3e42      not_full_power:	cpi	i_temp1, NO_POWER
0000fb f018      		brlo	neither_full_nor_off
                 	; POWER OFF
0000fc 7f8d      		cbr	flags1, (1<<FULL_POWER)	; tcnt0_power_on = NO_POWER means power off
0000fd 6081      		sbr	flags1, (1<<POWER_OFF)
0000fe c002      		rjmp	t0_int_exit
                 neither_full_nor_off:
0000ff 7f8d      		cbr	flags1, (1<<FULL_POWER)	; tcnt0_power_on = MAX_POWER means FULL_POWER
000100 7f8e      		cbr	flags1, (1<<POWER_OFF)
                 
000101 fd93      t0_int_exit:	sbrc	flags2, POFF_CYCLE
000102 6081      		sbr	flags1, (1<<POWER_OFF)
000103 be1f      		out	SREG, i_sreg
000104 9518      		reti
                 ;-----bko-----------------------------------------------------------------
                 ; beeper: timer0 is set to 1µs/count
000105 ec38      beep_f1:	ldi	temp4, 200
000106 e510      		ldi	temp2, 80
000107 c009      		rjmp	beep
                 
000108 eb34      beep_f2:	ldi	temp4, 180
000109 e614      		ldi	temp2, 100
00010a c006      		rjmp	beep
                 
00010b ea30      beep_f3:	ldi	temp4, 160
00010c e718      		ldi	temp2, 120
00010d c003      		rjmp	beep
                 
00010e e634      beep_f4:	ldi	temp4, 100
00010f ec18      		ldi	temp2, 200
000110 c000      		rjmp	beep
                 
000111 2700      beep:		clr	temp1
000112 bf02      		out	TCNT0, temp1
000113 9a97      		BpFET_on		; BpFET on
000114 9a90      		AnFET_on		; CnFET on
000115 b702      beep_BpCn10:	in	temp1, TCNT0
000116 3400      		cpi	temp1, 64		; 32µs on
000117 f7e9      		brne	beep_BpCn10
000118 9897      		BpFET_off		; BpFET off
000119 9890      		AnFET_off		; CnFET off
00011a e120      		ldi	temp3, 16		; 2040µs off
00011b 2700      beep_BpCn12:	clr	temp1
00011c bf02      		out	TCNT0, temp1
00011d b702      beep_BpCn13:	in	temp1, TCNT0
00011e 1703      		cp	temp1, temp4
00011f f7e9      		brne	beep_BpCn13
000120 952a      		dec	temp3
000121 f7c9      		brne	beep_BpCn12
000122 951a      		dec	temp2
000123 f769      		brne	beep
000124 9508      		ret
                 
000125 e11e      wait30ms:	ldi	temp2, 30
000126 e120      beep_BpCn20:	ldi	temp3, 16
000127 2700      beep_BpCn21:	clr	temp1
000128 bf02      		out	TCNT0, temp1
000129 b702      beep_BpCn22:	in	temp1, TCNT0
00012a 3f0f      		cpi	temp1, 255
00012b f7e9      		brne	beep_BpCn22
00012c 952a      		dec	temp3
00012d f7c9      		brne	beep_BpCn21
00012e 951a      		dec	temp2
00012f f7b1      		brne	beep_BpCn20
000130 9508      		ret
                 
                 	; 256 periods = 261ms silence
000131 e010      wait260ms:	ldi	temp2, 0	; = 256
000132 e120      beep2_BpCn20:	ldi	temp3, 16
000133 2700      beep2_BpCn21:	clr	temp1
000134 bf02      		out	TCNT0, temp1
000135 b702      beep2_BpCn22:	in	temp1, TCNT0
000136 3f0f      		cpi	temp1, 255
000137 f7e9      		brne	beep2_BpCn22
000138 952a      		dec	temp3
000139 f7c9      		brne	beep2_BpCn21
00013a 951a      		dec	temp2
00013b f7b1      		brne	beep2_BpCn20
00013c 9508      		ret
                 ;-----bko-----------------------------------------------------------------
00013d e030      tcnt1_to_temp:	ldi	temp4, EXT0_DIS		; disable ext0int
00013e bf3b      		out	GIMSK, temp4
00013f e030      		ldi	temp4, T1STOP		; stop timer1
000140 bd3e      		out	TCCR1B, temp4
000141 e032      		ldi	temp4, T1CK8		; preload temp with restart timer1
000142 b50c      		in	temp1, TCNT1L		;  - the preload cycle is needed to complete stop operation
000143 b51d      		in	temp2, TCNT1H
000144 bd3e      		out	TCCR1B, temp4
000145 9508      		ret				; !!! ext0int stays disabled - must be enabled again by caller
                 	; there seems to be only one TEMP register in the AVR
                 	; if the ext0int interrupt falls between readad LOW value while HIGH value is captured in TEMP and
                 	; read HIGH value, TEMP register is changed in ext0int routine
                 ;-----bko-----------------------------------------------------------------
                 evaluate_rc_puls:
000146 7e8f      		cbr	flags1, (1<<EVAL_RC_PULS)
000147 ff83      		sbrs	flags1, RC_PULS_UPDATED
000148 c01a      		rjmp	eval_rc_p90
000149 9100 0079 		lds	temp1, new_rcpuls_l
00014b 9110 007a 		lds	temp2, new_rcpuls_h
00014d 7f87      		cbr	flags1, (1<<RC_PULS_UPDATED) ; rc impuls value is read out
00014e 5908      		subi	temp1, low  (MIN_RC_PULS)
00014f 4018      		sbci	temp2, high (MIN_RC_PULS)
000150 f410      		brcc	eval_rc_p00
000151 2700      		clr	temp1
000152 2711      		clr	temp2
000153 9516      eval_rc_p00:	lsr	temp2	; actual 0->1600
000154 9507      		ror	temp1
000155 9516      		lsr	temp2	; actual 0->800
000156 9507      		ror	temp1
000157 9516      		lsr	temp2	; actual 0->400
000158 9507      		ror	temp1
                 		; now 0->200
                 
                 .if RANGE533MS == 1	; full rc-pulse-range is lower than 800ms - make 533ms range
                 .endif	; RANGE533MS == 1
                 
000159 2f20      		mov	temp3, temp1		
00015a 3c28      		cpi	temp3, POWER_RANGE
00015b f008      		brcs	eval_rc_p10
00015c ec28      		ldi	temp3, POWER_RANGE
00015d 2322      eval_rc_p10:	tst	temp3
00015e f019      		breq	eval_rc_p20
00015f 312e      		cpi	temp3, MIN_DUTY	; +20
000160 f408      		brcc	eval_rc_p20
000161 e12e      		ldi	temp3, MIN_DUTY	; +20
000162 2ff2      eval_rc_p20:	mov	ZH, temp3
000163 9508      eval_rc_p90:	ret
                 ;-----bko-----------------------------------------------------------------
                 evaluate_sys_state:
000164 7d8f      		cbr	flags1, (1<<EVAL_SYS_STATE)
000165 ff77      		sbrs	flags0, T1OVFL_FLAG
000166 c013      		rjmp	eval_sys_s99
                 
                 	; do it not more often as every 32µs
000167 777f      		cbr	flags0, (1<<T1OVFL_FLAG)
                 
                 	; control current
000168 c005      eval_sys_i:	rjmp	eval_sys_i_ok
                 
000169 2d4c      		mov	i_temp1, current_err
00016a 3043      		cpi	i_temp1, CURRENT_ERR_MAX
00016b f478      		brcc	panic_exit
00016c 94c3      		inc	current_err
00016d c003      		rjmp	eval_sys_ub
                 
00016e 20cc      eval_sys_i_ok:	tst	current_err
00016f f009      		breq	eval_sys_ub
000170 94ca      		dec	current_err
                 
                 	; control voltage
000171 c005      eval_sys_ub:	rjmp	eval_sys_ub_ok
                 
000172 2d4d      		mov	i_temp1, sys_control
000173 3c48      		cpi	i_temp1, POWER_RANGE
000174 f428      		brcc	eval_sys_s99
000175 94d3      		inc	sys_control
000176 c003      		rjmp	eval_sys_s99
                 
000177 20dd      eval_sys_ub_ok:	tst	sys_control
000178 f009      		breq	eval_sys_s99
000179 94da      		dec	sys_control
                 		
00017a 9508      eval_sys_s99:	ret
                 
                 panic_exit:	; !!!!!! OVERCURRENT !!!!!!!!
00017b 94f8      		cli
00017c ce9a      		rjmp	reset
                 ;-----bko-----------------------------------------------------------------
00017d 2f0f      set_new_duty:	mov	temp1, ZH
00017e 190d      		sub	temp1, sys_control
00017f f408      		brcc	set_new_duty10
000180 e10d      		ldi	temp1, MIN_DUTY-1
000181 9110 0066 set_new_duty10:	lds	temp2, timing_x
000183 2311      		tst	temp2
000184 f421      		brne	set_new_duty12
000185 9110 0065 		lds	temp2, timing_h	; get actual RPM reference high
000187 3810      		cpi	temp2, PWR_RANGE1	; lower range1 ?
000188 f038      		brcs	set_new_duty20		; on carry - test next range
000189 6091      set_new_duty12:	sbr	flags2, (1<<RPM_RANGE1)
00018a 6092      		sbr	flags2, (1<<RPM_RANGE2)
00018b e312      		ldi	temp2, PWR_MAX_RPM1	; higher than range1 power max ?
00018c 1701      		cp	temp1, temp2
00018d f098      		brcs	set_new_duty31		; on carry - not higher, no restriction
00018e 2f01      		mov	temp1, temp2		; low (range1) RPM - set PWR_MAX_RPM1
00018f c011      		rjmp	set_new_duty31
000190 ff95      set_new_duty20:	sbrs	flags2, STARTUP
000191 c005      		rjmp	set_new_duty25
000192 e223      		ldi	temp3, PWR_MAX_STARTUP	; limit power in startup phase
000193 1702      		cp	temp1, temp3
000194 f010      		brcs	set_new_duty25		; on carry - not higher, test range 2
000195 2f02      		mov	temp1, temp3		; set PWR_MAX_STARTUP limit
000196 c00a      		rjmp	set_new_duty31
000197 3410      set_new_duty25:	cpi	temp2, PWR_RANGE2	; lower range2 ?
000198 f038      		brcs	set_new_duty30		; on carry - not lower, no restriction
000199 7f9e      		cbr	flags2, (1<<RPM_RANGE1)
00019a 6092      		sbr	flags2, (1<<RPM_RANGE2)
00019b e614      		ldi	temp2, PWR_MAX_RPM2	; higher than range2 power max ?
00019c 1701      		cp	temp1, temp2
00019d f018      		brcs	set_new_duty31		; on carry - not higher, no restriction
00019e 2f01      		mov	temp1, temp2		; low (range2) RPM - set PWR_MAX_RPM2
00019f c001      		rjmp	set_new_duty31
0001a0 7f9c      set_new_duty30:	cbr	flags2, (1<<RPM_RANGE1)+(1<<RPM_RANGE2)
0001a1 9500      set_new_duty31:	com	temp1			; down-count to up-count (T0)
0001a2 2e60      		mov	tcnt0_pwron_next, temp1	; save in next
                 	; tcnt0_power_on is updated to tcnt0_pwron_next in acceptable steps
0001a3 9508      		ret
                 ;-----bko-----------------------------------------------------------------
0001a4 7b8f      evaluate_rpm:	cbr	flags1, (1<<EVAL_RPM)
0001a5 9120 006c 		lds	temp3, rpm_x
0001a7 9110 006b 		lds	temp2, rpm_h
                 
0001a9 9100 006a 		lds	temp1, rpm_l	; subtract 1/256
0001ab 1b01      		sub	temp1, temp2
0001ac 9300 006a 		sts	rpm_l, temp1
0001ae 9100 006b 		lds	temp1, rpm_h
0001b0 0b02      		sbc	temp1, temp3
0001b1 9300 006b 		sts	rpm_h, temp1
0001b3 9100 006c 		lds	temp1, rpm_x
0001b5 4000      		sbci	temp1, 0
0001b6 9300 006c 		sts	rpm_x, temp1
                 
0001b8 9120 0069 		lds	temp3, timing_acc_x
0001ba 9110 0068 		lds	temp2, timing_acc_h
0001bc 9100 0067 		lds	temp1, timing_acc_l
0001be 9526      		lsr	temp3		; make one complete commutation cycle
0001bf 9517      		ror	temp2
0001c0 9507      		ror	temp1
0001c1 9526      		lsr	temp3
0001c2 9517      		ror	temp2
0001c3 9507      		ror	temp1
                 	; temp3 is zero now - for sure !!
0001c4 9320 0069 		sts	timing_acc_x, temp3
0001c6 9320 0068 		sts	timing_acc_h, temp3
0001c8 9320 0067 		sts	timing_acc_l, temp3
                 	; and add the result as 1/256
0001ca 9120 006a 		lds	temp3, rpm_l
0001cc 0f20      		add	temp3, temp1
0001cd 9320 006a 		sts	rpm_l, temp3
0001cf 9120 006b 		lds	temp3, rpm_h
0001d1 1f21      		adc	temp3, temp2
0001d2 9320 006b 		sts	rpm_h, temp3
0001d4 e000      		ldi	temp1, 0
0001d5 9120 006c 		lds	temp3, rpm_x
0001d7 1f20      		adc	temp3, temp1
0001d8 9320 006c 		sts	rpm_x, temp3
                 
0001da 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 set_all_timings:
0001db eec8      		ldi	YL, low  (timeoutSTART)
0001dc efdd      		ldi	YH, high (timeoutSTART)
0001dd 93c0 0071 		sts	wt_OCT1_tot_l, YL
0001df 93d0 0072 		sts	wt_OCT1_tot_h, YH
0001e1 ef2f      		ldi	temp3, 0xff
0001e2 e13f      		ldi	temp4, 0x1f
0001e3 9320 006d 		sts	wt_comp_scan_l, temp3
0001e5 9330 006e 		sts	wt_comp_scan_h, temp4
0001e7 9320 006f 		sts	com_timing_l, temp3
0001e9 9330 0070 		sts	com_timing_h, temp4
                 
0001eb e0e3      set_timing_v:	ldi	ZL, 0x03
0001ec 93e0 0066 		sts	timing_x, ZL
0001ee ef3f      		ldi	temp4, 0xff
0001ef 9330 0065 		sts	timing_h, temp4
0001f1 ef2f      		ldi	temp3, 0xff
0001f2 9320 0064 		sts	timing_l, temp3
                 
0001f4 9508      		ret
                 ;-----bko-----------------------------------------------------------------
0001f5 df47      update_timing:	rcall	tcnt1_to_temp
0001f6 9300 0060 		sts	tcnt1_sav_l, temp1
0001f8 9310 0061 		sts	tcnt1_sav_h, temp2
0001fa 0f0c      		add	temp1, YL
0001fb 1f1d      		adc	temp2, YH
0001fc e035      		ldi	temp4, (1<<TOIE1)+(1<<TOIE0)
0001fd bf39      		out	TIMSK, temp4
0001fe bd1b      		out	OCR1AH, temp2
0001ff bd0a      		out	OCR1AL, temp1
000200 6071      		sbr	flags0, (1<<OCT1_PENDING)
000201 e135      		ldi	temp4, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; enable interrupt again
000202 bf39      		out	TIMSK, temp4
000203 e430      		ldi	temp4, EXT0_EN		; ext0int enable
000204 bf3b      		out	GIMSK, temp4		; enable ext0int
                 
                 	; calculate next waiting times - timing(-l-h-x) holds the time of 4 commutations
000205 9100 0064 		lds	temp1, timing_l
000207 9110 0065 		lds	temp2, timing_h
000209 91e0 0066 		lds	ZL, timing_x
                 
00020b 9300 0073 		sts	zero_wt_l, temp1	; save for zero crossing timeout
00020d 9310 0074 		sts	zero_wt_h, temp2
00020f 23ee      		tst	ZL
000210 f029      		breq	update_t00
000211 ef3f      		ldi	temp4, 0xff
000212 9330 0073 		sts	zero_wt_l, temp4	; save for zero crossing timeout
000214 9330 0074 		sts	zero_wt_h, temp4
                 update_t00:
000216 95e6      		lsr	ZL			; build a quarter
000217 9517      		ror	temp2
000218 9507      		ror	temp1
                 
000219 95e6      		lsr	ZL
00021a 9517      		ror	temp2
00021b 9507      		ror	temp1
00021c 9120 0064 		lds	temp3, timing_l		; .. and subtract from timing
00021e 9130 0065 		lds	temp4, timing_h
000220 91e0 0066 		lds	ZL, timing_x
000222 1b20      		sub	temp3, temp1
000223 0b31      		sbc	temp4, temp2
000224 40e0      		sbci	ZL, 0
                 
000225 9100 0060 		lds	temp1, tcnt1_sav_l	; calculate this commutation time
000227 9110 0061 		lds	temp2, tcnt1_sav_h
000229 91c0 0062 		lds	YL, last_tcnt1_l
00022b 91d0 0063 		lds	YH, last_tcnt1_h
00022d 9300 0062 		sts	last_tcnt1_l, temp1
00022f 9310 0063 		sts	last_tcnt1_h, temp2
000231 1b0c      		sub	temp1, YL
000232 0b1d      		sbc	temp2, YH
000233 9300 0075 		sts	last_com_l, temp1
000235 9310 0076 		sts	last_com_h, temp2
                 
000237 0f20      		add	temp3, temp1		; .. and add to timing
000238 1f31      		adc	temp4, temp2
000239 e010      		ldi	temp2, 0
00023a 1fe1      		adc	ZL, temp2
                 
                 	; limit RPM to 120.000
00023b 23ee      		tst	ZL
00023c f461      		brne	update_t90
00023d 2333      		tst	temp4
00023e f021      		breq	update_t10
00023f 3032      		cpi	temp4, 0x02
000240 f441      		brne	update_t90
000241 3928      		cpi	temp3, 0x98		; 0x298 = 120.000 RPM
000242 f430      		brcc	update_t90
                 	; set RPM to 120.000
000243 e032      update_t10:	ldi	temp4, 0x02
000244 e928      		ldi	temp3, 0x98
000245 20ff      		tst	run_control 
000246 f411      		brne	update_t90		; just active
000247 ef0f      		ldi	temp1, 0xff		; not active - reactivate
000248 2ef0      		mov	run_control, temp1
                 
000249 9320 0064 update_t90:	sts	timing_l, temp3
00024b 9330 0065 		sts	timing_h, temp4
00024d 93e0 0066 		sts	timing_x, ZL
00024f 30e4      		cpi	ZL, 4		; limit range to 0x3ffff
000250 f008      		brcs	update_t99
000251 df99      		rcall	set_timing_v
                 
000252 9100 0067 update_t99:	lds	temp1, timing_acc_l
000254 0f02      		add	temp1, temp3
000255 9300 0067 		sts	timing_acc_l, temp1
000257 9100 0068 		lds	temp1, timing_acc_h
000259 1f03      		adc	temp1, temp4
00025a 9300 0068 		sts	timing_acc_h, temp1
00025c 9100 0069 		lds	temp1, timing_acc_x
00025e 1f0e      		adc	temp1, ZL
00025f 9300 0069 		sts	timing_acc_x, temp1
                 
000261 95e6      		lsr	ZL			; a 16th is the next wait before scan
000262 9537      		ror	temp4
000263 9527      		ror	temp3
000264 95e6      		lsr	ZL
000265 9537      		ror	temp4
000266 9527      		ror	temp3
000267 95e6      		lsr	ZL
000268 9537      		ror	temp4
000269 9527      		ror	temp3
00026a 95e6      		lsr	ZL
00026b 9537      		ror	temp4
00026c 9527      		ror	temp3
00026d 9320 006d 		sts	wt_comp_scan_l, temp3
00026f 9330 006e 		sts	wt_comp_scan_h, temp4
                 
                 	; use the same value for commutation timing (15°)
000271 9320 006f 		sts	com_timing_l, temp3
000273 9330 0070 		sts	com_timing_h, temp4
                 
000275 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 calc_next_timing:
000276 91c0 006d 		lds	YL, wt_comp_scan_l	; holds wait-before-scan value
000278 91d0 006e 		lds	YH, wt_comp_scan_h
00027a df7a      		rcall	update_timing
                 
00027b 9508      		ret
                 
00027c fd70      wait_OCT1_tot:	sbrc	flags0, OCT1_PENDING
00027d cffe      		rjmp	wait_OCT1_tot
                 
00027e 9837      set_OCT1_tot:	cbi	ADCSRA, ADEN		; switch to comparator multiplexed
00027f b700      		in	temp1, SFIOR
000280 6008      		ori	temp1, (1<<ACME)
000281 bf00      		out	SFIOR, temp1
                 
000282 91d0 0074 		lds	YH, zero_wt_h
000284 91c0 0073 		lds	YL, zero_wt_l
000286 deb6      		rcall	tcnt1_to_temp
000287 0f0c      		add	temp1, YL
000288 1f1d      		adc	temp2, YH
000289 e035      		ldi	temp4, (1<<TOIE1)+(1<<TOIE0)
00028a bf39      		out	TIMSK, temp4
00028b bd1b      		out	OCR1AH, temp2
00028c bd0a      		out	OCR1AL, temp1
00028d 6071      		sbr	flags0, (1<<OCT1_PENDING)
00028e e135      		ldi	temp4, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
00028f bf39      		out	TIMSK, temp4
000290 e430      		ldi	temp4, EXT0_EN		; ext0int enable
000291 bf3b      		out	GIMSK, temp4		; enable ext0int
                 
000292 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 wait_OCT1_before_switch:
000293 dea9      		rcall	tcnt1_to_temp
000294 91c0 006f 		lds	YL, com_timing_l
000296 91d0 0070 		lds	YH, com_timing_h
000298 0f0c      		add	temp1, YL
000299 1f1d      		adc	temp2, YH
00029a e025      		ldi	temp3, (1<<TOIE1)+(1<<TOIE0)
00029b bf29      		out	TIMSK, temp3
00029c bd1b      		out	OCR1AH, temp2
00029d bd0a      		out	OCR1AL, temp1
00029e 6071      		sbr	flags0, (1<<OCT1_PENDING)
00029f e125      		ldi	temp3, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
0002a0 bf29      		out	TIMSK, temp3
0002a1 e430      		ldi	temp4, EXT0_EN		; ext0int enable
0002a2 bf3b      		out	GIMSK, temp4		; enable ext0int
                 
                 	; don't waste time while waiting - do some controls, if indicated
0002a3 fd84      		sbrc	flags1, EVAL_RC_PULS
0002a4 dea1      		rcall	evaluate_rc_puls
0002a5 fd85      		sbrc	flags1, EVAL_SYS_STATE
0002a6 debd      		rcall	evaluate_sys_state
                 
0002a7 fd87      		sbrc	flags1, EVAL_PWM
0002a8 ded4      		rcall	set_new_duty
                 
0002a9 fd86      		sbrc	flags1, EVAL_RPM
0002aa def9      		rcall	evaluate_rpm
                 
0002ab fd70      OCT1_wait:	sbrc	flags0, OCT1_PENDING
0002ac cffe      		rjmp	OCT1_wait
0002ad 9508      		ret
                 ;-----bko-----------------------------------------------------------------
0002ae 91c0 0071 start_timeout:	lds	YL, wt_OCT1_tot_l
0002b0 91d0 0072 		lds	YH, wt_OCT1_tot_h
0002b2 df42      		rcall	update_timing
                 
0002b3 b50c      		in	temp1, TCNT1L
0002b4 700f      		andi	temp1, 0x0f
0002b5 1bd0      		sub	YH, temp1
0002b6 3bdb      		cpi	YH, high (timeoutMIN)
0002b7 f408      		brcc	set_tot2
0002b8 efdd      		ldi	YH, high (timeoutSTART)		
                 set_tot2:
0002b9 93d0 0072 		sts	wt_OCT1_tot_h, YH
                 
0002bb d012      		rcall	sync_with_poweron	; wait at least 100+ microseconds
0002bc d011      		rcall	sync_with_poweron	; for demagnetisation - one sync may be added
                 
0002bd 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 switch_power_off:
0002be e1fd      		ldi	ZH, MIN_DUTY-1		; ZH is new_duty
0002bf ee02      		ldi	temp1, NO_POWER		; lowest tcnt0_power_on value
0002c0 2e20      		mov	tcnt0_power_on, temp1
0002c1 2e60      		mov	tcnt0_pwron_next, temp1
0002c2 e000      		ldi	temp1, INIT_PD		; all off
0002c3 bb02      		out	PORTD, temp1
0002c4 e001      		ldi	temp1, CHANGE_TIMEOUT	; reset change-timeout
0002c5 2e30      		mov	tcnt0_change_tot, temp1
0002c6 6081      		sbr	flags1, (1<<POWER_OFF)	; disable power on
0002c7 7f97      		cbr	flags2, (1<<POFF_CYCLE)
0002c8 6290      		sbr	flags2, (1<<STARTUP)
0002c9 9508      		ret				; motor is off
                 ;-----bko-----------------------------------------------------------------
0002ca e008      wait_if_spike:	ldi	temp1, 8
0002cb 950a      wait_if_spike2:	dec	temp1
0002cc f7f1      		brne	wait_if_spike2
0002cd 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 sync_with_poweron:
0002ce fd76      		sbrc	flags0, I_OFF_CYCLE	; first wait for power on
0002cf cffe      		rjmp	sync_with_poweron
                 wait_for_poweroff:
0002d0 ff76      		sbrs	flags0, I_OFF_CYCLE	; now wait for power off
0002d1 cffe      		rjmp	wait_for_poweroff
0002d2 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 motor_brake:
                 .if MOT_BRAKE == 1
                 .endif	; MOT_BRAKE == 1
0002d3 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 ; **** startup loop ****
0002d4 dfe9      init_startup:	rcall	switch_power_off
0002d5 dffd      		rcall	motor_brake
                 wait_for_power_on:
0002d6 de6f      		rcall	evaluate_rc_puls
0002d7 31fe      		cpi	ZH, MIN_DUTY
0002d8 f3e8      		brcs	wait_for_power_on
                 
0002d9 e10e      		ldi	temp1, PWR_STARTUP	; begin startup with low power
0002da 9500      		com	temp1
0002db 2e60      		mov	tcnt0_pwron_next, temp1
                 
0002dc 9837      		cbi	ADCSRA, ADEN		; switch to comparator multiplexed
0002dd b700      		in	temp1, SFIOR
0002de 6008      		ori	temp1, (1<<ACME)
0002df bf00      		out	SFIOR, temp1
                 
0002e0 2733      		clr	temp4
0002e1 e000      		ldi	temp1, INIT_PD		; all off
0002e2 bb02      		out	PORTD, temp1
0002e3 e10b      		ldi	temp1, 27		; wait about 5mikosec
0002e4 950a      FETs_off_wt:	dec	temp1
0002e5 f7f1      		brne	FETs_off_wt
                 
0002e6 d13c      		rcall	com5com6
0002e7 d141      		rcall	com6com1
                 
0002e8 7f9b      		cbr	flags2, (1<<SCAN_TIMEOUT)
0002e9 e000      		ldi	temp1, 0
0002ea 9300 007c 		sts	goodies, temp1
                 
0002ec e500      		ldi	temp1, 80	; x 32msec
0002ed 2ee0      		mov	t1_timeout, temp1
                 
0002ee deec      		rcall	set_all_timings
                 
0002ef dfbe      		rcall	start_timeout
                 
                 	; fall through start1
                 
                 ;-----bko-----------------------------------------------------------------
                 ; **** start control loop ****
                 
                 ; state 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
0002f0 ff94      start1:		sbrs	flags2, COMP_SAVE	; high ?
0002f1 c010      		rjmp	start1_2		; .. no - loop, while high
                 
0002f2 fd70      start1_0:	sbrc	flags0, OCT1_PENDING
0002f3 c002      		rjmp	start1_1
0002f4 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
0002f5 c013      		rjmp	start1_9
0002f6 dfd7      start1_1:	rcall	sync_with_poweron
                 
0002f7 fd94      		sbrc	flags2, COMP_SAVE	; high ?
0002f8 cff9      		rjmp	start1_0		; .. no - loop, while high
                 
                 ; do the special 120° switch
0002f9 e000      		ldi	temp1, 0
0002fa 9300 007c 		sts	goodies, temp1
0002fc d0f8      		rcall	com1com2
0002fd d0fd      		rcall	com2com3
0002fe d10d      		rcall	com3com4
0002ff de46      		rcall	evaluate_rc_puls
000300 dfad      		rcall	start_timeout
000301 c031      		rjmp	start4
                 	
000302 fd70      start1_2:	sbrc	flags0, OCT1_PENDING
000303 c002      		rjmp	start1_3
000304 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000305 c003      		rjmp	start1_9
000306 dfc7      start1_3:	rcall	sync_with_poweron
000307 ff94      		sbrs	flags2, COMP_SAVE	; high ?
000308 cff9      		rjmp	start1_2		; .. no - loop, while low
                 
                 start1_9:
000309 d0eb      		rcall	com1com2
00030a dfa3      		rcall	start_timeout
                 
                 ; state 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
                 
00030b fd94      start2:		sbrc	flags2, COMP_SAVE
00030c c008      		rjmp	start2_2
                 
00030d fd70      start2_0:	sbrc	flags0, OCT1_PENDING
00030e c002      		rjmp	start2_1
00030f 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000310 c00b      		rjmp	start2_9
000311 dfbc      start2_1:	rcall	sync_with_poweron
000312 ff94      		sbrs	flags2, COMP_SAVE
000313 cff9      		rjmp	start2_0
000314 c007      		rjmp	start2_9
                 
000315 fd70      start2_2:	sbrc	flags0, OCT1_PENDING
000316 c002      		rjmp	start2_3
000317 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000318 c003      		rjmp	start2_9
000319 dfb4      start2_3:	rcall	sync_with_poweron
00031a fd94      		sbrc	flags2, COMP_SAVE
00031b cff9      		rjmp	start2_2
                 
                 start2_9:
00031c d0de      		rcall	com2com3
00031d de28      		rcall	evaluate_rc_puls
00031e df8f      		rcall	start_timeout
                 
                 ; state 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 
00031f ff94      start3:		sbrs	flags2, COMP_SAVE
000320 c008      		rjmp	start3_2
                 
000321 fd70      start3_0:	sbrc	flags0, OCT1_PENDING
000322 c002      		rjmp	start3_1
000323 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000324 c00b      		rjmp	start3_9
000325 dfa8      start3_1:	rcall	sync_with_poweron
000326 fd94      		sbrc	flags2, COMP_SAVE
000327 cff9      		rjmp	start3_0
000328 c007      		rjmp	start3_9
                 
000329 fd70      start3_2:	sbrc	flags0, OCT1_PENDING
00032a c002      		rjmp	start3_3
00032b 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
00032c c003      		rjmp	start3_9
00032d dfa0      start3_3:	rcall	sync_with_poweron
00032e ff94      		sbrs	flags2, COMP_SAVE
00032f cff9      		rjmp	start3_2
                 
                 start3_9:
000330 d0db      		rcall	com3com4
000331 de4b      		rcall	set_new_duty
000332 df7b      		rcall	start_timeout
                 
                 ; state 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
                 
000333 fd94      start4:		sbrc	flags2, COMP_SAVE
000334 c008      		rjmp	start4_2
                 
000335 fd70      start4_0:	sbrc	flags0, OCT1_PENDING
000336 c002      		rjmp	start4_1
000337 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000338 c00b      		rjmp	start4_9
000339 df94      start4_1:	rcall	sync_with_poweron
00033a ff94      		sbrs	flags2, COMP_SAVE
00033b cff9      		rjmp	start4_0
00033c c007      		rjmp	start4_9
                 
00033d fd70      start4_2:	sbrc	flags0, OCT1_PENDING
00033e c002      		rjmp	start4_3
00033f 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000340 c003      		rjmp	start4_9
000341 df8c      start4_3:	rcall	sync_with_poweron
000342 fd94      		sbrc	flags2, COMP_SAVE
000343 cff9      		rjmp	start4_2
                 
                 start4_9:
000344 d0cd      		rcall	com4com5
000345 df68      		rcall	start_timeout
                 
                 
                 ; state 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
                 
                 
000346 ff94      start5:		sbrs	flags2, COMP_SAVE
000347 c008      		rjmp	start5_2
                 
000348 fd70      start5_0:	sbrc	flags0, OCT1_PENDING
000349 c002      		rjmp	start5_1
00034a 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
00034b c00b      		rjmp	start5_9
00034c df81      start5_1:	rcall	sync_with_poweron
00034d fd94      		sbrc	flags2, COMP_SAVE
00034e cff9      		rjmp	start5_0
00034f c007      		rjmp	start5_9
                 
000350 fd70      start5_2:	sbrc	flags0, OCT1_PENDING
000351 c002      		rjmp	start5_3
000352 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000353 c003      		rjmp	start5_9
000354 df79      start5_3:	rcall	sync_with_poweron
000355 ff94      		sbrs	flags2, COMP_SAVE
000356 cff9      		rjmp	start5_2
                 
                 start5_9:
000357 d0cb      		rcall	com5com6
000358 de0b      		rcall	evaluate_sys_state
000359 df54      		rcall	start_timeout
                 
                 ; state 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
                 
00035a fd94      start6:		sbrc	flags2, COMP_SAVE
00035b c008      		rjmp	start6_2
                 
00035c fd70      start6_0:	sbrc	flags0, OCT1_PENDING
00035d c002      		rjmp	start6_1
00035e 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
00035f c00b      		rjmp	start6_9
000360 df6d      start6_1:	rcall	sync_with_poweron
000361 ff94      		sbrs	flags2, COMP_SAVE
000362 cff9      		rjmp	start6_0
000363 c007      		rjmp	start6_9
                 
000364 fd70      start6_2:	sbrc	flags0, OCT1_PENDING
000365 c002      		rjmp	start6_3
000366 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000367 c003      		rjmp	start6_9
000368 df65      start6_3:	rcall	sync_with_poweron
000369 fd94      		sbrc	flags2, COMP_SAVE
00036a cff9      		rjmp	start6_2
                 
                 start6_9:
00036b d0bd      		rcall	com6com1
                 
00036c 2d02      		mov	temp1, tcnt0_power_on
00036d 3e02      		cpi	temp1, NO_POWER
00036e f409      		brne	s6_power_ok
00036f cf64      		rjmp	init_startup
                 
000370 20ee      s6_power_ok:	tst	t1_timeout
000371 f409      		brne	s6_test_rpm
000372 cf61      		rjmp	init_startup		;-) demich
                 		
000373 9100 0066 s6_test_rpm:	lds	temp1, timing_x
000375 2300      		tst	temp1
000376 f421      		brne	s6_goodies
000377 9100 0065 		lds	temp1, timing_h		; get actual RPM reference high
                 ;		cpi	temp1, PWR_RANGE1
000379 3400      		cpi	temp1, PWR_RANGE2
00037a f050      		brcs	s6_run1
                 
00037b 9100 007c s6_goodies:	lds	temp1, goodies
00037d fd92      		sbrc	flags2, SCAN_TIMEOUT
00037e 2700      		clr	temp1
00037f 9503      		inc	temp1
000380 9300 007c 		sts	goodies,  temp1
000382 7f9b      		cbr	flags2, (1<<SCAN_TIMEOUT)
000383 330c      		cpi	temp1, ENOUGH_GOODIES
000384 f030      		brcs	s6_start1	
                 
000385 ef0f      s6_run1:	ldi	temp1, 0xff
000386 2ef0      		mov	run_control, temp1
                 
000387 deee      		rcall	calc_next_timing
000388 def5      		rcall	set_OCT1_tot
                 
000389 7d9f      		cbr	flags2, (1<<STARTUP)
00038a c002      		rjmp	run1			; running state begins
                 
00038b df22      s6_start1:	rcall	start_timeout		; need to be here for a correct temp1=comp_state
00038c cf63      		rjmp	start1			; go back to state 1
                 
                 ;-----bko-----------------------------------------------------------------
                 ; **** running control loop ****
                 
                 ; run 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
                 
00038d d057      run1: 		rcall	wait_for_low
00038e ff70      		sbrs	flags0, OCT1_PENDING
00038f c043      		rjmp	run_to_start
000390 d05c      		rcall	wait_for_high
000391 ff70      		sbrs	flags0, OCT1_PENDING
000392 c040      		rjmp	run_to_start
000393 6480      		sbr	flags1, (1<<EVAL_RPM)
000394 defe      		rcall	wait_OCT1_before_switch
000395 d05f      		rcall	com1com2
000396 dedf      		rcall	calc_next_timing
000397 dee4      		rcall	wait_OCT1_tot
                 		
                 ; run 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
                 
000398 d054      run2:		rcall	wait_for_high
000399 ff70      		sbrs	flags0, OCT1_PENDING
00039a c038      		rjmp	run_to_start
00039b d049      		rcall	wait_for_low
00039c ff70      		sbrs	flags0, OCT1_PENDING
00039d c035      		rjmp	run_to_start
00039e 6180      		sbr	flags1, (1<<EVAL_RC_PULS)
00039f def3      		rcall	wait_OCT1_before_switch
0003a0 d05a      		rcall	com2com3
0003a1 ded4      		rcall	calc_next_timing
0003a2 ded9      		rcall	wait_OCT1_tot
                 
                 ; run 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 
0003a3 d041      run3:		rcall	wait_for_low
0003a4 ff70      		sbrs	flags0, OCT1_PENDING
0003a5 c02d      		rjmp	run_to_start
0003a6 d046      		rcall	wait_for_high
0003a7 ff70      		sbrs	flags0, OCT1_PENDING
0003a8 c02a      		rjmp	run_to_start
0003a9 6880      		sbr	flags1, (1<<EVAL_PWM)
0003aa dee8      		rcall	wait_OCT1_before_switch
0003ab d060      		rcall	com3com4
0003ac dec9      		rcall	calc_next_timing
0003ad dece      		rcall	wait_OCT1_tot
                 
                 ; run 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
0003ae d03e      run4:		rcall	wait_for_high
0003af ff70      		sbrs	flags0, OCT1_PENDING
0003b0 c022      		rjmp	run_to_start
0003b1 d033      		rcall	wait_for_low
0003b2 ff70      		sbrs	flags0, OCT1_PENDING
0003b3 c01f      		rjmp	run_to_start
0003b4 dede      		rcall	wait_OCT1_before_switch
0003b5 d05c      		rcall	com4com5
0003b6 debf      		rcall	calc_next_timing
0003b7 dec4      		rcall	wait_OCT1_tot
                 
                 ; run 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
                 
0003b8 d02c      run5:		rcall	wait_for_low
0003b9 ff70      		sbrs	flags0, OCT1_PENDING
0003ba c018      		rjmp	run_to_start
0003bb d031      		rcall	wait_for_high
0003bc ff70      		sbrs	flags0, OCT1_PENDING
0003bd c015      		rjmp	run_to_start
0003be 6280      		sbr	flags1, (1<<EVAL_SYS_STATE)
0003bf ded3      		rcall	wait_OCT1_before_switch
0003c0 d062      		rcall	com5com6
0003c1 deb4      		rcall	calc_next_timing
0003c2 deb9      		rcall	wait_OCT1_tot
                 
                 ; run 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
                 
0003c3 d029      run6:		rcall	wait_for_high
0003c4 ff70      		sbrs	flags0, OCT1_PENDING
0003c5 c00d      		rjmp	run_to_start
0003c6 d01e      		rcall	wait_for_low
0003c7 ff70      		sbrs	flags0, OCT1_PENDING
0003c8 c00a      		rjmp	run_to_start
0003c9 dec9      		rcall	wait_OCT1_before_switch
0003ca d05e      		rcall	com6com1
0003cb deaa      		rcall	calc_next_timing
0003cc deaf      		rcall	wait_OCT1_tot
                 
                 ;		rjmp	run6_2
                 
0003cd 9100 0066 		lds	temp1, timing_x
0003cf 2300      		tst	temp1
0003d0 f029      		breq	run6_2			; higher than 610 RPM if zero
0003d1 950a      		dec	temp1
0003d2 f019      		breq	run6_2			; higher than 610 RPM if equ 1
0003d3 6290      run_to_start:	sbr	flags2, (1<<STARTUP)
0003d4 7f97      		cbr	flags2, (1<<POFF_CYCLE)
0003d5 cf00      		rjmp	wait_for_power_on
                 
0003d6 7f97      run6_2:		cbr	flags2, (1<<POFF_CYCLE)
0003d7 20ff      		tst	run_control		; only once !
0003d8 f041      		breq	run6_9
0003d9 94fa      		dec	run_control
0003da f029      		breq	run6_3			; poweroff if 0
0003db 2d0f      		mov	temp1, run_control
0003dc 3001      		cpi	temp1, 1		; poweroff if 1
0003dd f011      		breq	run6_3
0003de 3002      		cpi	temp1, 2		; poweroff if 2
0003df f409      		brne	run6_9
0003e0 6098      run6_3:		sbr	flags2, (1<<POFF_CYCLE)
                 
                 run6_9:
0003e1 cfab      		rjmp	run1			; go back to run 1
                 
                 restart_control:
0003e2 94f8      		cli				; disable all interrupts
0003e3 deda      		rcall	switch_power_off
0003e4 cc32      		rjmp	reset
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; *** scan comparator utilities ***
                 ; 
0003e5 ff70      wait_for_low:	sbrs	flags0, OCT1_PENDING
0003e6 9508      		ret
0003e7 9b45      		sbis	ACSR, ACO		; low ?
0003e8 cffc      		rjmp	wait_for_low		; .. no - loop, while high
0003e9 dee0      		rcall	wait_if_spike		; .. yes - look for a spike
0003ea 9b45      		sbis	ACSR, ACO		; test again
0003eb cff9      		rjmp	wait_for_low		; .. is high again, was a spike
0003ec 9508      		ret
                 
0003ed ff70      wait_for_high:	sbrs	flags0, OCT1_PENDING
0003ee 9508      		ret
0003ef 9945      		sbic	ACSR, ACO		; high ?
0003f0 cffc      		rjmp	wait_for_high		; .. no - loop, while low
0003f1 ded8      		rcall	wait_if_spike		; .. yes - look for a spike
0003f2 9945      		sbic	ACSR, ACO		; test again
0003f3 cff9      		rjmp	wait_for_high		; .. is low again, was a spike
0003f4 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 ; *** commutation utilities ***
0003f5 9897      com1com2:	BpFET_off		; Bp off
0003f6 ff80      		sbrs	flags1, POWER_OFF
0003f7 9a95      		ApFET_on		; Ap on
0003f8 e003      		ldi	temp1, mux_b		; set comparator multiplexer to phase B
0003f9 b907      		out	ADMUX, temp1
0003fa 9508      		ret
                 
0003fb e104      com2com3:	ldi	temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
0003fc bf09      		out	TIMSK, temp1		;  .. only ONE should change these values at the time
0003fd 0000      		nop
0003fe 7d7f      		cbr	flags0, (1<<A_FET)	; next nFET = BnFET
0003ff 7e7f      		cbr	flags0, (1<<C_FET)
000400 fd81      		sbrc	flags1, FULL_POWER
000401 c002      		rjmp	c2_switch
000402 fd76      		sbrc	flags0, I_OFF_CYCLE	; was power off ?
000403 c003      		rjmp	c2_done			; .. yes - futhermore work is done in timer0 interrupt
000404 9893      c2_switch:	CnFET_off		; Cn off
000405 ff80      		sbrs	flags1, POWER_OFF
000406 9a91      		BnFET_on		; Bn on
000407 e105      c2_done:	ldi	temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
000408 bf09      		out	TIMSK, temp1
000409 e004      		ldi	temp1, mux_c		; set comparator multiplexer to phase C
00040a b907      		out	ADMUX, temp1
00040b 9508      		ret
                 
00040c 9895      com3com4:	ApFET_off		; Ap off
00040d ff80      		sbrs	flags1, POWER_OFF
00040e 9a94      		CpFET_on		; Cp on
00040f e002      		ldi	temp1, mux_a		; set comparator multiplexer to phase A
000410 b907      		out	ADMUX, temp1
000411 9508      		ret
                 
000412 e104      com4com5:	ldi	temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
000413 bf09      		out	TIMSK, temp1		;  .. only ONE should change these values at the time
000414 0000      		nop
000415 6270      		sbr	flags0, (1<<A_FET)	; next nFET = AnFET
000416 7e7f      		cbr	flags0, (1<<C_FET)
000417 fd81      		sbrc	flags1, FULL_POWER
000418 c002      		rjmp	c4_switch
000419 fd76      		sbrc	flags0, I_OFF_CYCLE	; was power off ?
00041a c003      		rjmp	c4_done			; .. yes - futhermore work is done in timer0 interrupt
00041b 9891      c4_switch:	BnFET_off		; Bn off
00041c ff80      		sbrs	flags1, POWER_OFF
00041d 9a90      		AnFET_on		; An on
00041e e105      c4_done:	ldi	temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
00041f bf09      		out	TIMSK, temp1
000420 e003      		ldi	temp1, mux_b		; set comparator multiplexer to phase B
000421 b907      		out	ADMUX, temp1
000422 9508      		ret
                 
000423 9894      com5com6:	CpFET_off		; Cp off
000424 ff80      		sbrs	flags1, POWER_OFF
000425 9a97      		BpFET_on		; Bp on
000426 e004      		ldi	temp1, mux_c		; set comparator multiplexer to phase C
000427 b907      		out	ADMUX, temp1
000428 9508      		ret
                 
000429 e104      com6com1:	ldi	temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
00042a bf09      		out	TIMSK, temp1		;  .. only ONE should change these values at the time
00042b 0000      		nop
00042c 7d7f      		cbr	flags0, (1<<A_FET)	; next nFET = CnFET
00042d 6170      		sbr	flags0, (1<<C_FET)
00042e fd81      		sbrc	flags1, FULL_POWER
00042f c002      		rjmp	c6_switch
000430 fd76      		sbrc	flags0, I_OFF_CYCLE	; was power off ?
000431 c003      		rjmp	c6_done			; .. yes - futhermore work is done in timer0 interrupt
000432 9890      c6_switch:	AnFET_off		; An off
000433 ff80      		sbrs	flags1, POWER_OFF
000434 9a93      		CnFET_on		; Cn on
000435 e105      c6_done:	ldi	temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
000436 bf09      		out	TIMSK, temp1
000437 e002      		ldi	temp1, mux_a		; set comparator multiplexer to phase A
000438 b907      		out	ADMUX, temp1
000439 9508      		ret
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega8 register use summary:
r0 :   0 r1 :   8 r2 :   7 r3 :   6 r4 :   0 r5 :   0 r6 :   4 r7 :   2 
r8 :   2 r9 :   0 r10:   0 r11:   6 r12:   5 r13:   6 r14:   4 r15:   6 
r16: 194 r17:  54 r18:  57 r19:  48 r20:  38 r21:  19 r22:  12 r23:  54 
r24:  41 r25:  54 r26:   2 r27:   1 r28:  11 r29:  15 r30:  17 r31:   5 
x  :   1 y  :   0 z  :   0 
Registers used: 28 out of 35 (80.0%)

ATmega8 instruction use summary:
.lds  :   0 .sts  :   0 adc   :   9 add   :   6 adiw  :   0 and   :   0 
andi  :   1 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   8 brcs  :  10 breq  :  13 brge  :   0 brhc  :   0 brhs  :   0 
brid  :   0 brie  :   0 brlo  :   4 brlt  :   0 brmi  :   0 brne  :  24 
brpl  :   0 brsh  :   4 brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 
bset  :   0 bst   :   0 cbi   :  13 cbr   :  27 clc   :   0 clh   :   0 
cli   :   3 cln   :   0 clr   :  15 cls   :   0 clt   :   0 clv   :   0 
clz   :   0 com   :   3 cp    :   5 cpc   :   4 cpi   :  26 cpse  :   0 
dec   :  19 eor   :   0 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 
ijmp  :   0 in    :  18 inc   :   4 ld    :   0 ldd   :   0 ldi   :  99 
lds   :  44 lpm   :   0 lsl   :   0 lsr   :  11 mov   :  33 movw  :   0 
mul   :   0 muls  :   0 mulsu :   0 neg   :   0 nop   :  12 or    :   0 
ori   :   2 out   :  62 pop   :   0 push  :   0 rcall : 105 ret   :  28 
reti  :   4 rjmp  : 125 rol   :   0 ror   :  19 sbc   :   5 sbci  :   4 
sbi   :  11 sbic  :   4 sbis  :   3 sbiw  :   0 sbr   :  36 sbrc  :  38 
sbrs  :  46 sec   :   0 seh   :   0 sei   :   2 sen   :   0 ser   :   0 
ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 spm   :   0 
st    :   1 std   :   0 sts   :  47 sub   :   7 subi  :   3 swap  :   0 
tst   :  15 wdr   :   0 
Instructions used: 46 out of 110 (41.8%)

ATmega8 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000874   2146     18   2164    8192  26.4%
[.dseg] 0x000060 0x0000e3      0    131    131    1024  12.8%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings

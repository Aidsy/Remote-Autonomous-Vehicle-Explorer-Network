
AVRASM ver. 2.1.42  C:\Users\test\Documents\AirHacks\codebase\ESC Firmware\HK-SS_20a_ppm\HK-SS 20a.asm Mon Jan 24 19:59:29 2011

C:\Users\test\Documents\AirHacks\codebase\ESC Firmware\HK-SS_20a_ppm\HK-SS 20a.asm(42): Including file 'C:\Program Files\Atmel\AVR Tools\AvrAssembler2\Appnotes\m8def.inc'
C:\Users\test\Documents\AirHacks\codebase\ESC Firmware\HK-SS_20a_ppm\HK-SS 20a.asm(66): Including file 'C:\Users\test\Documents\AirHacks\codebase\ESC Firmware\HK-SS_20a_ppm\tp-18a.inc'
                 
                 
                 ;
                 ;Die Benutzung der Software ist mit folgenden Bedingungen verbunden:
                 ;
                 ;1. Da ich alles kostenlos zur Verfügung stelle, gebe ich keinerlei Garantie
                 ;   und übernehme auch keinerlei Haftung für die Folgen der Benutzung.
                 ;
                 ;2. Die Software ist ausschließlich zur privaten Nutzung bestimmt. Ich
                 ;   habe nicht geprüft, ob bei gewerblicher Nutzung irgendwelche Patentrechte
                 ;   verletzt werden oder sonstige rechtliche Einschränkungen vorliegen.
                 ;
                 ;3. Jeder darf Änderungen vornehmen, z.B. um die Funktion seinen Bedürfnissen
                 ;   anzupassen oder zu erweitern. Ich würde mich freuen, wenn ich weiterhin als
                 ;   Co-Autor in den Unterlagen erscheine und mir ein Link zur entprechenden Seite
                 ;   (falls vorhanden) mitgeteilt wird.
                 ;
                 ;4. Auch nach den Änderungen sollen die Software weiterhin frei sein, d.h. kostenlos bleiben.
                 ;
                 ;!! Wer mit den Nutzungbedingungen nicht einverstanden ist, darf die Software nicht nutzen !!
                 ;
                 ; October 2004
                 ; autor: Bernhard Konze
                 ; email: bernhard.konze@versanet.de
                 ;
                 ;**** **** **** **** ****
                 ; Modified 1 April 2010 for HobbyKing 25-30A Super Simple programmable ESCs.
                 ; This is particualrly aimed at Tricopter usage with HobbyKing 401b gyros.
                 ; Modifications are: Lowered minium throttle threshold for better low speed range.
                 ; Reduced the minimum allowable time between pulses to allow for 401b's digital mode.
                 ; This version is still compatible with the TowerPro 18A
                 ;**** **** **** **** ****
                 ;Modified 11 April 2010
                 ;Removed reboot if rc pulse is noisy (poor bad signal)
                 ;Now it just zeros the throttle
                 ;
                 ;Tweaked startup power and timing for smoother startup
                 ;**** **** **** **** ****
                 
                 ; Device
                 ;
                 ;**** **** **** **** ****
                 .include "m8def.inc"
                 
                 ;***** Created: 2009-11-03 14:40 ******* Source: ATmega8.xml *************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m8def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega8
                 ;* Date              : 2009-11-03
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega8
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M8DEF_INC_
                 #define _M8DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega8
                 #pragma AVRPART ADMIN PART_NAME ATmega8
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x93
                 .equ	SIGNATURE_002	= 0x07
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	GICR	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCR	= 0x37
                 .equ	TWCR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUCSR	= 0x34
                 .equ	TCCR0	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	SFIOR	= 0x30
                 .equ	TCCR1A	= 0x2f
                 .equ	TCCR1B	= 0x2e
                 .equ	TCNT1L	= 0x2c
                 .equ	TCNT1H	= 0x2d
                 .equ	OCR1AL	= 0x2a
                 .equ	OCR1AH	= 0x2b
                 .equ	OCR1BL	= 0x28
                 .equ	OCR1BH	= 0x29
                 .equ	ICR1L	= 0x26
                 .equ	ICR1H	= 0x27
                 .equ	TCCR2	= 0x25
                 .equ	TCNT2	= 0x24
                 .equ	OCR2	= 0x23
                 .equ	ASSR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	UBRRH	= 0x20
                 .equ	UCSRC	= 0x20
                 .equ	EEARL	= 0x1e
                 .equ	EEARH	= 0x1f
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PORTC	= 0x15
                 .equ	DDRC	= 0x14
                 .equ	PINC	= 0x13
                 .equ	PORTD	= 0x12
                 .equ	DDRD	= 0x11
                 .equ	PIND	= 0x10
                 .equ	SPDR	= 0x0f
                 .equ	SPSR	= 0x0e
                 .equ	SPCR	= 0x0d
                 .equ	UDR	= 0x0c
                 .equ	UCSRA	= 0x0b
                 .equ	UCSRB	= 0x0a
                 .equ	UBRRL	= 0x09
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCL	= 0x04
                 .equ	ADCH	= 0x05
                 .equ	TWDR	= 0x03
                 .equ	TWAR	= 0x02
                 .equ	TWSR	= 0x01
                 .equ	TWBR	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; SFIOR - Special Function IO Register
                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; GICR - General Interrupt Control Register
                 .equ	GIMSK	= GICR	; For compatibility
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                 
                 ; GIFR - General Interrupt Flag Register
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 .equ	INTF1	= 7	; External Interrupt Flag 1
                 
                 ; MCUCR - MCU Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 
                 ; TCCR0 - Timer/Counter0 Control Register
                 .equ	CS00	= 0	; Clock Select0 bit 0
                 .equ	CS01	= 1	; Clock Select0 bit 1
                 .equ	CS02	= 2	; Clock Select0 bit 2
                 
                 ; TCNT0 - Timer Counter 0
                 .equ	TCNT00	= 0	; Timer Counter 0 bit 0
                 .equ	TCNT01	= 1	; Timer Counter 0 bit 1
                 .equ	TCNT02	= 2	; Timer Counter 0 bit 2
                 .equ	TCNT03	= 3	; Timer Counter 0 bit 3
                 .equ	TCNT04	= 4	; Timer Counter 0 bit 4
                 .equ	TCNT05	= 5	; Timer Counter 0 bit 5
                 .equ	TCNT06	= 6	; Timer Counter 0 bit 6
                 .equ	TCNT07	= 7	; Timer Counter 0 bit 7
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	FOC1B	= 2	; Force Output Compare 1B
                 .equ	FOC1A	= 3	; Force Output Compare 1A
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	CTC1	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                 .equ	OCF2	= 7	; Output Compare Flag 2
                 
                 ; TCCR2 - Timer/Counter2 Control Register
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM21	= 3	; Waveform Generation Mode
                 .equ	CTC2	= WGM21	; For compatibility
                 .equ	COM20	= 4	; Compare Output Mode bit 0
                 .equ	COM21	= 5	; Compare Output Mode bit 1
                 .equ	WGM20	= 6	; Waveform Genration Mode
                 .equ	PWM2	= WGM20	; For compatibility
                 .equ	FOC2	= 7	; Force Output Compare
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2 - Timer/Counter2 Output Compare Register
                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                 
                 
                 ; ***** USART ************************
                 ; UDR - USART I/O Data Register
                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSRA - USART Control and Status Register A
                 .equ	USR	= UCSRA	; For compatibility
                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                 .equ	U2X	= 1	; Double the USART transmission speed
                 .equ	UPE	= 2	; Parity Error
                 .equ	PE	= UPE	; For compatibility
                 .equ	DOR	= 3	; Data overRun
                 .equ	FE	= 4	; Framing Error
                 .equ	UDRE	= 5	; USART Data Register Empty
                 .equ	TXC	= 6	; USART Transmitt Complete
                 .equ	RXC	= 7	; USART Receive Complete
                 
                 ; UCSRB - USART Control and Status Register B
                 .equ	UCR	= UCSRB	; For compatibility
                 .equ	TXB8	= 0	; Transmit Data Bit 8
                 .equ	RXB8	= 1	; Receive Data Bit 8
                 .equ	UCSZ2	= 2	; Character Size
                 .equ	CHR9	= UCSZ2	; For compatibility
                 .equ	TXEN	= 3	; Transmitter Enable
                 .equ	RXEN	= 4	; Receiver Enable
                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSRC - USART Control and Status Register C
                 .equ	UCPOL	= 0	; Clock Polarity
                 .equ	UCSZ0	= 1	; Character Size
                 .equ	UCSZ1	= 2	; Character Size
                 .equ	USBS	= 3	; Stop Bit Select
                 .equ	UPM0	= 4	; Parity Mode Bit 0
                 .equ	UPM1	= 5	; Parity Mode Bit 1
                 .equ	UMSEL	= 6	; USART Mode Select
                 .equ	URSEL	= 7	; Register Select
                 
                 .equ	UBRRHI	= UBRRH	; For compatibility
                 
                 ; ***** TWI **************************
                 ; TWBR - TWI Bit Rate register
                 .equ	I2BR	= TWBR	; For compatibility
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	I2CR	= TWCR	; For compatibility
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	I2IE	= TWIE	; For compatibility
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	I2EN	= TWEN	; For compatibility
                 .equ	ENI2C	= TWEN	; For compatibility
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	I2WC	= TWWC	; For compatibility
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	I2STO	= TWSTO	; For compatibility
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	I2STA	= TWSTA	; For compatibility
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	I2EA	= TWEA	; For compatibility
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 .equ	I2INT	= TWINT	; For compatibility
                 
                 ; TWSR - TWI Status Register
                 .equ	I2SR	= TWSR	; For compatibility
                 .equ	TWPS0	= 0	; TWI Prescaler
                 .equ	TWS0	= TWPS0	; For compatibility
                 .equ	I2GCE	= TWPS0	; For compatibility
                 .equ	TWPS1	= 1	; TWI Prescaler
                 .equ	TWS1	= TWPS1	; For compatibility
                 .equ	TWS3	= 3	; TWI Status
                 .equ	I2S3	= TWS3	; For compatibility
                 .equ	TWS4	= 4	; TWI Status
                 .equ	I2S4	= TWS4	; For compatibility
                 .equ	TWS5	= 5	; TWI Status
                 .equ	I2S5	= TWS5	; For compatibility
                 .equ	TWS6	= 6	; TWI Status
                 .equ	I2S6	= TWS6	; For compatibility
                 .equ	TWS7	= 7	; TWI Status
                 .equ	I2S7	= TWS7	; For compatibility
                 
                 ; TWDR - TWI Data register
                 .equ	I2DR	= TWDR	; For compatibility
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	I2AR	= TWAR	; For compatibility
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EEWEE	= EEMWE	; For compatibility
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 .equ	SM0	= 4	; Sleep Mode Select
                 .equ	SM1	= 5	; Sleep Mode Select
                 .equ	SM2	= 6	; Sleep Mode Select
                 .equ	SE	= 7	; Sleep Enable
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	MCUSR	= MCUCSR	; For compatibility
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; SPMCR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read-While-Write Section Read Enable
                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	PUD	= 2	; Pull-up Disable
                 .equ	ADHSM	= 4	; ADC High Speed Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADCSR	= ADCSRA	; For compatibility
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADFR	= 5	; ADC  Free Running Select
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	BODEN	= 6	; Brown out detector enable
                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	CKOPT	= 4	; Oscillator Options
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	WTDON	= 6	; Enable watchdog
                 .equ	RSTDISBL	= 7	; Disable reset
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 1024
                 .equ	RAMEND	= 0x045f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x01ff
                 .equ	EEPROMEND	= 0x01ff
                 .equ	EEADRBITS	= 9
                 #pragma AVRPART MEMORY PROG_FLASH 8192
                 #pragma AVRPART MEMORY EEPROM 512
                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0xc00
                 .equ	NRWW_STOP_ADDR	= 0xfff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0xbff
                 .equ	PAGESIZE	= 32
                 .equ	FIRSTBOOTSTART	= 0xf80
                 .equ	SECONDBOOTSTART	= 0xf00
                 .equ	THIRDBOOTSTART	= 0xe00
                 .equ	FOURTHBOOTSTART	= 0xc00
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                 .equ	OC2addr	= 0x0003	; Timer/Counter2 Compare Match
                 .equ	OVF2addr	= 0x0004	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x0005	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x0006	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0007	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x0008	; Timer/Counter1 Overflow
                 .equ	OVF0addr	= 0x0009	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x000a	; Serial Transfer Complete
                 .equ	URXCaddr	= 0x000b	; USART, Rx Complete
                 .equ	UDREaddr	= 0x000c	; USART Data Register Empty
                 .equ	UTXCaddr	= 0x000d	; USART, Tx Complete
                 .equ	ADCCaddr	= 0x000e	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x000f	; EEPROM Ready
                 .equ	ACIaddr	= 0x0010	; Analog Comparator
                 .equ	TWIaddr	= 0x0011	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0012	; Store Program Memory Ready
                 
                 .equ	INT_VECTORS_SIZE	= 19	; size in words
                 
                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                 
                 #endif  /* _M8DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 ;
                 ; 8K Bytes of In-System Self-Programmable Flash
                 ; 512 Bytes EEPROM
                 ; 1K Byte Internal SRAM
                 ;**** **** **** **** ****
                 ;**** **** **** **** ****
                 ; fuses must be set to internal calibrated oscillator = 8 mhz
                 ;**** **** **** **** ****
                 ;**** **** **** **** ****
                 
                 .equ MOT_BRAKE    = 0
                 
                 .equ UART_CONTROL = 0
                 .equ RC_PULS 	  = 1
                 
                 .equ RANGE533MS	= 0
                 
                 .if RANGE533MS == 1
                 .else
                 	.equ	MIN_RC_PULS	= 1000	; µs (or lower) = NO_POWER
                 .endif	; RANGE533MS == 1
                 
                 .include "tp-18a.inc"
                 
                 ;* TP-18A                                                  *
                 ;* Mai.2007
                 ;* http://home.versanet.de/~b-konze/                       *
                 ;*********************************************************** 
                 
                 #define Typ "tp-18a"
                 
                 ; activate Motor brake 
                 
                 ;.equ MOT_BRAKE      = 0
                 
                 ;Select Brake Power
                 ;	1 = min Brake
                 ;	2 = medium Brake
                 ;  	3 = hard Brake
                 
                 .equ BrakeSelect    = 2
                 
                 .equ CALIBRATE			= 1      
                 .equ OSCAL_VALUE		= 0x01ff 	; eeprom position
                 
                 .equ FORCE_LIPO 	= 1			; 1=Lipo und 0=NC wenn keine Buecke
                 .equ ActiveFreeRun	= 0
                 
                 ;**** **** **** **** ****
                 ; PORT  definitions
                 ;**** **** **** **** ****
                 
                 ;*********************
                 ; PORT D 
                 ;*********************  
                 .equ    mux_c   	= 7     ;i <plus> comparator input (AIN0)
                 .equ	c_comp		= 6	;i common comparator input (AIN0)
                 .equ	ApFET		= 5	;o
                 .equ	BpFET		= 4	;o
                 .equ	CpFET		= 3	;o
                 .equ	rcp_in		= 2	;i r/c pulse input
                 
                 .equ	INIT_PD		= 0
                 .equ	DIR_PD		= (1<<ApFET)+(1<<BpFET)+(1<<CpFET)
                 .equ	BRAKE_PD	= 0
                 
                 #define ApFET_on	sbi	PORTD,5
                 #define ApFET_off	cbi	PORTD,5
                 #define BpFET_on	sbi	PORTD,4
                 #define BpFET_off	cbi	PORTD,4
                 #define CpFET_on	sbi	PORTD,3
                 #define CpFET_off	cbi	PORTD,3
                 
                 
                 ;*********************
                 ; PORT C definitions *
                 ;*********************
                 .equ	mux_a		= 5	; ADC5 phase input
                 .equ	mux_b		= 4	; ADC4 phase input
                 ;.equ    	  	= 3	; ADC3
                 ;.equ    	  	= 2	; ADC2
                 .equ 	temp_adc	= 1 	; ADC1 temperature control input 
                 .equ 	accu_adc	= 0 	; ADC0 voltage control input 
                 
                 ;*********************
                 ; ADC only
                 ;*********************
                 ;.equ    	  	= 7	; ADC7
                 ;.equ    	  	= 6	; ADC6
                 
                 .equ	INIT_PC		= 0
                 .equ	DIR_PC		= 0
                 .equ	BRAKE_PC	= 0
                 
                 
                 ;*********************
                 ; PORT B definitions *
                 ;*********************
                 ;.equ		= 7	
                 ;.equ		= 6	
                 ;.equ		= 5    	(sck stk200 interface) 
                 ;.equ		= 4	(miso stk200 interface)
                 ;.equ		= 3	(mosi stk200 interface) 
                 ;.equ		= 2	
                 ;.equ		= 1	
                 ;.equ		= 0
                 
                 .equ	AnFET		= 2	;o
                 .equ	BnFET		= 1	;o
                 .equ	CnFET		= 0	;o
                 
                 .equ	INIT_PB		= 0
                 .equ	DIR_PB		= (1<<AnFET)+(1<<BnFET)+(1<<CnFET)
                 .equ	BRAKE_PB	= (1<<AnFET)+(1<<BnFET)+(1<<CnFET)
                 
                 #define AnFET_on	sbi	PORTB,2
                 #define AnFET_off	cbi	PORTB,2
                 #define BnFET_on	sbi	PORTB,1
                 #define BnFET_off	cbi	PORTB,1
                 #define CnFET_on	sbi	PORTB,0
                 #define CnFET_off	cbi	PORTB,0
                 
                 
                 
                 
                 .equ	CHANGE_TIMEOUT	= 1
                 .equ	CHANGE_TOT_LOW	= 1
                 
                 .equ	POWER_RANGE	= 100			; full range of tcnt0 setting
                 .equ	MIN_DUTY	= 10		; no power
                 .equ	NO_POWER	= 256-MIN_DUTY		; (POWER_OFF)
                 .equ	MAX_POWER	= 256-POWER_RANGE	; (FULL_POWER)
                 
                 .equ	PWR_MAX_RPM1	= POWER_RANGE/4
                 .equ	PWR_MAX_RPM2	= POWER_RANGE/2
                 
                 .equ	PWR_STARTUP	= MIN_DUTY
                 .equ	PWR_MAX_STARTUP	= MIN_DUTY + 5
                 
                 .equ	timeoutSTART	= 69000
                 .equ	timeoutMIN	= 36000
                 
                 .equ	T1STOP	= 0x00
                 .equ	T1CK8	= 0x02
                 
                 .equ	EXT0_DIS	= 0x00	; disable ext0int
                 .if RC_PULS == 1
                 .equ	EXT0_EN		= 0x40	; enable ext0int
                 .else
                 .endif
                 
                 .equ	OCT1_RANGE1	= 16	; ( ~2400 RPM )
                 .equ	OCT1_RANGE2	= 8	; ( ~4800 RPM )
                 
                 .equ	PWR_RANGE1	= 0x40	; ( ~2400 RPM )
                 .equ	PWR_RANGE2	= 0x20	; ( ~4800 RPM )
                 
                 .equ	ENOUGH_GOODIES	= 60
                 
                 ;**** **** **** **** ****
                 ; Register Definitions
                 .def	i_sreg		 = r1	; status register save in interrupts
                 .def	tcnt0_power_on	 = r2	; timer0 counts nFETs are switched on
                 .def	tcnt0_change_tot = r3	; when zero, tcnt0_power_on is changed by one (inc or dec)
                 ;.def	...	 	 = r4	; upper 8bit timer1 (software-) register
                 .def	uart_cnt	 = r5
                 .def	tcnt0_pwron_next = r6
                 
                 .def	start_rcpuls_l	 = r7
                 .def	start_rcpuls_h	 = r8
                 ;.def		 	 = r9
                 ;.def			 = r10
                 .def	rcpuls_timeout	 = r11
                 .equ	RCP_TOT		 = 100  ;maximum rcpulse errors
                 
                 .def	current_err	 = r12	; counts consecutive current errors
                 .equ	CURRENT_ERR_MAX  = 3	; performs a reset after MAX errors
                 
                 .def	sys_control	 = r13
                 .def	t1_timeout	 = r14
                 .def	run_control	 = r15
                 
                 
                 .def	temp1	= r16			; main temporary
                 .def	temp2	= r17			; main temporary
                 .def	temp3	= r18			; main temporary
                 .def	temp4	= r19			; main temporary
                 
                 .def	i_temp1	= r20			; interrupt temporary
                 .def	i_temp2	= r21			; interrupt temporary
                 .def	i_temp3	= r22			; interrupt temporary
                 
                 .def	flags0	= r23	; state flags
                 	.equ	OCT1_PENDING	= 0	; if set, output compare interrunpt is pending
                 	.equ	UB_LOW 		= 1	; set if accu voltage low
                 	.equ	I_pFET_HIGH	= 2	; set if over-current detect
                 	.equ	GET_STATE	= 3	; set if state is to be send
                 	.equ	C_FET		= 4	; if set, C-FET state is to be changed
                 	.equ	A_FET		= 5	; if set, A-FET state is to be changed
                 	     ; if neither 1 nor 2 is set, B-FET state is to be changed
                 	.equ	I_OFF_CYCLE	= 6	; if set, current off cycle is active
                 	.equ	T1OVFL_FLAG	= 7	; each timer1 overflow sets this flag - used for voltage + current watch
                 
                 .def	flags1	= r24	; state flags
                 	.equ	POWER_OFF	= 0	; switch fets on disabled
                 	.equ	FULL_POWER	= 1	; 100% on - don't switch off, but do OFF_CYCLE working
                 	.equ	CALC_NEXT_OCT1	= 2	; calculate OCT1 offset, when wait_OCT1_before_switch is called
                 	.equ	RC_PULS_UPDATED	= 3	; new rc-puls value available
                 	.equ	EVAL_RC_PULS	= 4	; if set, new rc puls is evaluated, while waiting for OCT1
                 	.equ	EVAL_SYS_STATE	= 5	; if set, overcurrent and undervoltage are checked
                 	.equ	EVAL_RPM	= 6	; if set, next PWM on should look for current
                 	.equ	EVAL_UART	= 7	; if set, next PWM on should look for uart
                 
                 .def	flags2	= r25
                 	.equ	RPM_RANGE1	= 0	; if set RPM is lower than 1831 RPM
                 	.equ	RPM_RANGE2	= 1	; if set RPM is between 1831 RPM and 3662 RPM
                 	.equ	SCAN_TIMEOUT	= 2	; if set a startup timeout occurred
                 	.equ	POFF_CYCLE	= 3	; if set one commutation cycle is performed without power
                 	.equ	COMP_SAVE	= 4	; if set ACO was high
                 	.equ	STARTUP		= 5	; if set startup-phase is active
                 	.equ	RC_INTERVAL_OK	= 6	; 
                 	.equ	GP_FLAG		= 7	; 
                 
                 ; here the XYZ registers are placed ( r26-r31)
                 
                 ; ZH = new_duty		; PWM destination
                 
                 
                 ;**** **** **** **** ****
                 ; RAM Definitions
                 .dseg					;EEPROM segment
                 .org SRAM_START
                 
000060           tcnt1_sav_l:	.byte	1	; actual timer1 value
000061           tcnt1_sav_h:	.byte	1
000062           last_tcnt1_l:	.byte	1	; last timer1 value
000063           last_tcnt1_h:	.byte	1
000064           timing_l:	.byte	1	; holds time of 4 commutations 
000065           timing_h:	.byte	1
000066           timing_x:	.byte	1
                 
000067           timing_acc_l:	.byte	1	; holds the average time of 4 commutations 
000068           timing_acc_h:	.byte	1
000069           timing_acc_x:	.byte	1
                 
00006a           rpm_l:		.byte	1	; holds the average time of 4 commutations 
00006b           rpm_h:		.byte	1
00006c           rpm_x:		.byte	1
                 
                 
                 
00006d           wt_comp_scan_l:	.byte	1	; time from switch to comparator scan
00006e           wt_comp_scan_h:	.byte	1       
00006f           com_timing_l:	.byte	1	; time from zero-crossing to switch of the appropriate FET
000070           com_timing_h:	.byte	1
000071           wt_OCT1_tot_l:	.byte	1	; OCT1 waiting time
000072           wt_OCT1_tot_h:	.byte	1
000073           zero_wt_l:	.byte	1
000074           zero_wt_h:	.byte	1
000075           last_com_l:	.byte	1
000076           last_com_h:	.byte	1
                 
000077           stop_rcpuls_l:	.byte	1
000078           stop_rcpuls_h:	.byte	1
000079           new_rcpuls_l:	.byte	1
00007a           new_rcpuls_h:	.byte	1
                 
00007b           duty_offset:	.byte	1
00007c           goodies:	.byte	1
00007d           comp_state:	.byte	1
00007e           gp_cnt:		.byte	1
                 
00007f           uart_data:	.byte	100		; only for debug requirements
                 
                 
                 ;**** **** **** **** ****
                 ; ATmega8 interrupts
                 
                 ;.equ	INT0addr=$001	; External Interrupt0 Vector Address
                 ;.equ	INT1addr=$002	; External Interrupt1 Vector Address
                 ;.equ	OC2addr =$003	; Output Compare2 Interrupt Vector Address
                 ;.equ	OVF2addr=$004	; Overflow2 Interrupt Vector Address
                 ;.equ	ICP1addr=$005	; Input Capture1 Interrupt Vector Address
                 ;.equ	OC1Aaddr=$006	; Output Compare1A Interrupt Vector Address
                 ;.equ	OC1Baddr=$007	; Output Compare1B Interrupt Vector Address
                 ;.equ	OVF1addr=$008	; Overflow1 Interrupt Vector Address
                 ;.equ	OVF0addr=$009	; Overflow0 Interrupt Vector Address
                 ;.equ	SPIaddr =$00a	; SPI Interrupt Vector Address
                 ;.equ	URXCaddr=$00b	; USART Receive Complete Interrupt Vector Address
                 ;.equ	UDREaddr=$00c	; USART Data Register Empty Interrupt Vector Address
                 ;.equ	UTXCaddr=$00d	; USART Transmit Complete Interrupt Vector Address
                 ;.equ	ADCCaddr=$00e	; ADC Interrupt Vector Address
                 ;.equ	ERDYaddr=$00f	; EEPROM Interrupt Vector Address
                 ;.equ	ACIaddr =$010	; Analog Comparator Interrupt Vector Address
                 ;.equ	TWIaddr =$011	; Irq. vector address for Two-Wire Interface
                 ;.equ	SPMaddr =$012	; SPM complete Interrupt Vector Address
                 ;.equ	SPMRaddr =$012	; SPM complete Interrupt Vector Address
                 ;-----bko-----------------------------------------------------------------
                 
                 ;**** **** **** **** ****
                 .cseg
                 .org 0
                 ;**** **** **** **** ****
                 
                 ;-----bko-----------------------------------------------------------------
                 ; reset and interrupt jump table
000000 c015      		rjmp	reset
                 .if RC_PULS == 1
000001 c062      		rjmp	ext_int0
                 .else
                 .endif	; RC_PULS == 1
000002 0000      		nop	; ext_int1
000003 0000      		nop	; t2oc_int
000004 0000      		nop	; t2ovfl_int
000005 0000      		nop	; icp1
000006 c0b0      		rjmp	t1oca_int
000007 0000      		nop	; t1ocb_int
000008 c0b2      		rjmp	t1ovfl_int
000009 c0bb      		rjmp	t0ovfl_int
00000a 0000      		nop	; spi_int
00000b 0000      		nop	; urxc
00000c 0000      		nop	; udre
                 .if UART_CONTROL == 1
                 .else
00000d 0000      		nop	; utxc
                 .endif	; UART_CONTROL == 1
                 ; not used	nop	; adc_int
                 ; not used	nop	; eep_int
                 ; not used	nop	; aci_int
                 ; not used	nop	; wire2_int
                 ; not used	nop	; spmc_int
                 
                 
00000e 0a0d      version:	.db	0x0d, 0x0a
00000f 7074
000010 3831
000011 3461
000012 3031
000013 3072
000014 2035      		.db	"tp18a410r05 "
000015 0a0d      version_end:	.db	0x0d, 0x0a
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; init after reset
                 
000016 e004      reset:		ldi	temp1, high(RAMEND)	; stack = RAMEND
000017 bf0e      		out	SPH, temp1
000018 e50f      		ldi	temp1, low(RAMEND)
000019 bf0d      		out 	SPL, temp1
                 	; oscillator calibration byte is written into the uppermost position
                 	; of the eeprom - by the script 1n1p.e2s an ponyprog
                 ;CLEARBUFFER
                 ;LOAD-PROG 1n1p.hex
                 ;PAUSE "Connect and powerup the circuit, are you ready?"
                 ;READ-CALIBRATION 0x21FF DATA 3     # <EEProm 8Mhz
                 ;ERASE-ALL
                 ;WRITE&VERIFY-ALL
                 ;		ldi 	temp1,0x01
                 ;		out	EEARH,temp1
                 ;		ldi	temp1,$ff
                 ;		out	EEARL,temp1
                 ;		sbi	EECR,EERE
                 ;		in	temp1,EEDR
                 ;		out 	osccal ,temp1  ;schreiben
                 
                 	; portB - all FETs off
00001a e000      		ldi	temp1, INIT_PB		; PORTB initially holds 0x00
00001b bb08      		out	PORTB, temp1
00001c e007      		ldi	temp1, DIR_PB
00001d bb07      		out	DDRB, temp1
                 
                 	; portC reads comparator inputs
00001e e000      		ldi	temp1, INIT_PC
00001f bb05      		out	PORTC, temp1
000020 e000      		ldi	temp1, DIR_PC
000021 bb04      		out	DDRC, temp1
                 
                 	; portD reads rc-puls + AIN0 ( + RxD, TxD for debug )
000022 e000      		ldi	temp1, INIT_PD
000023 bb02      		out	PORTD, temp1
000024 e308      		ldi	temp1, DIR_PD
000025 bb01      		out	DDRD, temp1
                 
                 	; timer0: PWM + beep control = 0x02 	; start timer0 with CK/8 (1µs/count)
000026 e002      		ldi	temp1, 0x02
000027 bf03      		out	TCCR0, temp1
                 
                 	; timer1: commutation control = 0x02	; start timer1 with CK/8 (1µs/count)
000028 e002      		ldi	temp1, T1CK8
000029 bd0e      		out	TCCR1B, temp1
                 
                 	; reset state flags
00002a 2777      		clr	flags0
00002b 2788      		clr	flags1
00002c 2799      		clr	flags2
                 
                 	; clear RAM
00002d 27bb      		clr	XH
00002e e6a0      		ldi	XL, low (SRAM_START)
00002f 2700      		clr	temp1
000030 930d      clear_ram:	st	X+, temp1
000031 38a0      		cpi	XL, uart_data+1
000032 f3e8      		brlo	clear_ram
                 
                 	; power off
000033 d28e      		rcall	switch_power_off
                 
                 	; reset rc puls timeout
000034 e604      		ldi	temp1, RCP_TOT
000035 2eb0      		mov	rcpuls_timeout, temp1
                 		
                 .if UART_CONTROL == 1
                 .endif
000036 d102      		rcall	wait260ms	; wait a while
000037 d101      		rcall	wait260ms
                 
                 .if UART_CONTROL == 1
                 .endif
                 
000038 d0d4      		rcall	beep_f1
000039 d0f3      		rcall	wait30ms
00003a d0d5      		rcall	beep_f2
00003b d0f1      		rcall	wait30ms
00003c d0d6      		rcall	beep_f3
00003d d0ef      		rcall	wait30ms
                 
                 .if UART_CONTROL == 1
                 .endif
                 
                 control_start:	; init variables
00003e e001      		ldi	temp1, CHANGE_TIMEOUT
00003f 2e30      		mov	tcnt0_change_tot, temp1
000040 ef06      		ldi	temp1, NO_POWER
000041 2e20      		mov	tcnt0_power_on, temp1
                 
000042 e000      		ldi	temp1, 0		; reset error counters
000043 2ec0      		mov	current_err,temp1
000044 2ed0      		mov	sys_control, temp1
                 
                 	; init registers and interrupts
000045 e105      		ldi	temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
000046 bf08      		out	TIFR, temp1		; clear TOIE1,OCIE1A & TOIE0
000047 bf09      		out	TIMSK, temp1		; enable TOIE1,OCIE1A & TOIE0 interrupts
                 
                 .if UART_CONTROL == 1
                 .endif
                 
000048 9478      		sei				; enable all interrupts
                 
                 .if RC_PULS == 1
                 ; init rc-puls
000049 e003      		ldi	temp1, (1<<ISC01)+(1<<ISC00)
00004a bf05      		out	MCUCR, temp1		; set next int0 to rising edge
00004b e400      		ldi	temp1, EXT0_EN		; enable ext0int
00004c bf0b      		out	GIMSK, temp1
00004d e02a      i_rc_puls1:	ldi	temp3, 10		; wait for this count of receiving power off
00004e ff83      i_rc_puls2:	sbrs	flags1, RC_PULS_UPDATED
00004f cffe      		rjmp	i_rc_puls2
000050 9100 0079 		lds	temp1, new_rcpuls_l
000052 9110 007a 		lds	temp2, new_rcpuls_h
000054 7f87      		cbr	flags1, (1<<RC_PULS_UPDATED) ; rc impuls value is read out
000055 5e08      		subi	temp1, low  (MIN_RC_PULS)	; power off received ?
000056 4013      		sbci	temp2, high (MIN_RC_PULS)
000057 f7a8      		brcc	i_rc_puls1		; no - reset counter
000058 952a      		dec	temp3			; yes - decrement counter
000059 f7a1      		brne	i_rc_puls2		; repeat until zero
00005a 94f8      		cli				; disable all interrupts
00005b d0ba      		rcall	beep_f4			; signal: rcpuls ready
00005c d0b9      		rcall	beep_f4
00005d d0b8      		rcall	beep_f4
00005e 9478      		sei				; enable all interrupts
                 .endif
                 
                 .if UART_CONTROL == 1
                 .endif
                 
00005f e10e      		ldi	temp1, 30
000060 9300 007b 		sts	duty_offset, temp1
                 
000062 d15b      		rcall	set_all_timings
                 
000063 c276      		rjmp	init_startup
                 		
                 ;-----bko-----------------------------------------------------------------
                 ; external interrupt0 = rc pulse input
                 .if RC_PULS == 1
000064 b61f      ext_int0:	in	i_sreg, SREG
000065 2744      		clr	i_temp1			; disable extint edge may be changed
000066 bf4b      		out	GIMSK, i_temp1
                 
                 ; evaluate edge of this interrupt
000067 b745      		in	i_temp1, MCUCR
000068 ff40      		sbrs	i_temp1, ISC00
000069 c027      		rjmp	falling_edge		; bit is clear = falling edge
                 
                 ; should be rising edge - test rc impuls level state for possible jitter
00006a 9b82      		sbis	PIND, rcp_in
00006b c047      		rjmp	extint1_exit		; jump, if low state
                 
                 ; rc impuls is at high state
00006c e042      		ldi	i_temp1, (1<<ISC01)
00006d bf45      		out	MCUCR, i_temp1		; set next int0 to falling edge
                 
                 ; get timer1 values
00006e b54c      		in	i_temp1, TCNT1L
00006f b55d      		in	i_temp2, TCNT1H
000070 2e74      		mov	start_rcpuls_l, i_temp1
000071 2e85      		mov	start_rcpuls_h, i_temp2
                 ; test rcpulse interval
000072 7b9f      		cbr	flags2, (1<<RC_INTERVAL_OK) ; preset to not ok
000073 9160 0077 		lds	i_temp3, stop_rcpuls_l
000075 1b46      		sub	i_temp1, i_temp3
000076 9160 0078 		lds	i_temp3, stop_rcpuls_h
000078 0b56      		sbc	i_temp2, i_temp3
000079 3a48      		cpi	i_temp1, low (25000)
00007a e661      		ldi	i_temp3, high(25000)	; test range high
00007b 0756      		cpc	i_temp2, i_temp3
00007c f430      		brsh	extint1_fail		; through away
00007d 3f44      		cpi	i_temp1, low (500)
00007e e061      		ldi	i_temp3, high(500)	; test range low
00007f 0756      		cpc	i_temp2, i_temp3
000080 f010      		brlo	extint1_fail		; through away
000081 6490      		sbr	flags2, (1<<RC_INTERVAL_OK) ; set to rc impuls value is ok !
000082 c030      		rjmp	extint1_exit
                 
000083 20bb      extint1_fail:	tst	rcpuls_timeout
000084 f011      		breq	extint1_timedout
000085 94ba      		dec		rcpuls_timeout
000086 c02c      		rjmp	extint1_exit
                 
                 extint1_timedout:
000087 6490      		sbr	flags2, (1<<RC_INTERVAL_OK)
000088 e604      		ldi	temp1, RCP_TOT
000089 2eb0      		mov	rcpuls_timeout, temp1
00008a ee09      		ldi temp1, low(MIN_RC_PULS + 1)
00008b 9300 0079 		sts new_rcpuls_l, temp1 
00008d e003      		ldi temp1, high(MIN_RC_PULS + 1)
00008e 9300 007a 		sts new_rcpuls_h, temp1 ;set rcpulse to just above initialization threshold
000090 c022      		rjmp	extint1_exit
                 
                 
                 ; rc impuls is at low state
000091 9982      falling_edge:	sbic	PIND, rcp_in		; test level of rc impuls
000092 c020      		rjmp	extint1_exit		; seems to be a spike
                 
000093 e043      		ldi	i_temp1, (1<<ISC01)+(1<<ISC00)
000094 bf45      		out	MCUCR, i_temp1		; set next int0 to rising edge
000095 fd83      		sbrc	flags1, RC_PULS_UPDATED
000096 c01c      		rjmp	extint1_exit
                 
                 ; get timer1 values
000097 b54c      		in	i_temp1, TCNT1L
000098 b55d      		in	i_temp2, TCNT1H
000099 9340 0077 		sts	stop_rcpuls_l, i_temp1	; prepare next interval evaluation
00009b 9350 0078 		sts	stop_rcpuls_h, i_temp2
                 
00009d ff96      		sbrs	flags2, RC_INTERVAL_OK
00009e c014      		rjmp	extint1_exit
00009f 7b9f      		cbr	flags2, (1<<RC_INTERVAL_OK) ; flag is evaluated
                 
0000a0 1947      		sub	i_temp1, start_rcpuls_l
0000a1 0958      		sbc	i_temp2, start_rcpuls_h
                 
                 	; save impuls length
0000a2 9340 0079 		sts	new_rcpuls_l, i_temp1
0000a4 9350 007a 		sts	new_rcpuls_h, i_temp2
0000a6 3948      		cpi	i_temp1, low (2200)
0000a7 e068      		ldi	i_temp3, high(2200)	; test range high
0000a8 0756      		cpc	i_temp2, i_temp3
0000a9 f6c8      		brsh	extint1_fail		; through away
0000aa 3240      		cpi	i_temp1, low (800)
0000ab e063      		ldi	i_temp3, high(800)	; test range low
0000ac 0756      		cpc	i_temp2, i_temp3
0000ad f2a8      		brlo	extint1_fail		; through away
0000ae 6088      		sbr	flags1, (1<<RC_PULS_UPDATED) ; set to rc impuls value is ok !
0000af 2d4b      		mov	i_temp1, rcpuls_timeout
0000b0 3644      		cpi	i_temp1, RCP_TOT
0000b1 f009      		breq	extint1_exit
0000b2 94b3      		inc	rcpuls_timeout
                 
                 ; enable int1 again -  also entry for spike detect
0000b3 e450      extint1_exit:	ldi	i_temp2, EXT0_EN
0000b4 bf5b      		out	GIMSK, i_temp2
0000b5 be1f      		out	SREG, i_sreg
0000b6 9518      		reti
                 .endif  ; RC_PULS == 1
                 ;-----bko-----------------------------------------------------------------
                 ; output compare timer1 interrupt
0000b7 b61f      t1oca_int:	in	i_sreg, SREG
0000b8 7f7e      		cbr	flags0, (1<<OCT1_PENDING) ; signal OCT1 passed
0000b9 be1f      		out	SREG, i_sreg
0000ba 9518      		reti
                 ;-----bko-----------------------------------------------------------------
                 ; overflow timer1 / happens all 65536µs
0000bb b61f      t1ovfl_int:	in	i_sreg, SREG
0000bc 6870      		sbr	flags0, (1<<T1OVFL_FLAG)
                 
0000bd 20ee      		tst	t1_timeout
0000be f009      		breq	t1ovfl_10
0000bf 94ea      		dec	t1_timeout
                 t1ovfl_10:
                 .if RC_PULS == 1
0000c0 20bb      		tst	rcpuls_timeout
0000c1 f009      		breq	t1ovfl_99
0000c2 94ba      		dec	rcpuls_timeout
                 .endif
                 
0000c3 be1f      t1ovfl_99:	out	SREG, i_sreg
0000c4 9518      		reti
                 ;-----bko-----------------------------------------------------------------
                 ; timer0 overflow interrupt
0000c5 b61f      t0ovfl_int:	in	i_sreg, SREG
0000c6 fd76      		sbrc	flags0, I_OFF_CYCLE
0000c7 c026      		rjmp	t0_on_cycle
                 
0000c8 6190      t0_off_cycle:	sbr	flags2, (1<<COMP_SAVE)
0000c9 9945      		sbic	ACSR, ACO		; mirror inverted ACO to bit-var
0000ca 7e9f      		cbr	flags2, (1<<COMP_SAVE)
                 
                 	; changes in PWM ?
0000cb 2d42      		mov	i_temp1, tcnt0_power_on
0000cc 2d56      		mov	i_temp2, tcnt0_pwron_next
0000cd 1754      		cp	i_temp2, i_temp1
0000ce f430      		brsh	lower_pwm		; next power-on-time is lower or same
0000cf 943a      higher_pwm:	dec	tcnt0_change_tot	; change-timeout passed ?
0000d0 f459      		brne	nFET_off		; .. no
0000d1 e051      		ldi	i_temp2, CHANGE_TIMEOUT	; .. yes - change-timeout for more power
0000d2 2e35      		mov	tcnt0_change_tot, i_temp2 ; reset change-timeout and decrement
0000d3 954a      		dec	i_temp1			; <dec> increases power-on-time
0000d4 c006      		rjmp	set_next_pwm
                 
0000d5 f031      lower_pwm:	breq	nFET_off		; pwm is unchanged
0000d6 943a      		dec	tcnt0_change_tot	; change-timeout passed ?
0000d7 f421      		brne	nFET_off		; .. no
0000d8 e051      		ldi	i_temp2, CHANGE_TOT_LOW ; .. yes - change-timeout for lower power
0000d9 2e35      		mov	tcnt0_change_tot, i_temp2 ; reset change-timeout and increment
0000da 9543      		inc	i_temp1			; <inc> decreases power-on-time
                 
0000db 2e24      set_next_pwm:	mov	tcnt0_power_on, i_temp1
                 
0000dc 6470      nFET_off:	sbr	flags0, (1<<I_OFF_CYCLE) ; PWM state = off cycle
                 
                 	; switch appropriate nFET off
0000dd ff74      		sbrs	flags0, C_FET
0000de c003      		rjmp	test_AnFET
                 
                 ; C_FET is active
0000df ff81      		sbrs	flags1, FULL_POWER
0000e0 98c0      		CnFET_off		; Cn off
0000e1 c007      		rjmp	reload_t0_off_cycle
                 
0000e2 ff75      test_AnFET:	sbrs	flags0, A_FET
0000e3 c003      		rjmp	switch_BnFET
                 
                 ; A_FET is active
0000e4 ff81      switch_AnFET:	sbrs	flags1, FULL_POWER
0000e5 98c2      		AnFET_off		; An off
0000e6 c002      		rjmp	reload_t0_off_cycle
                 
                 ; B_FET is active
0000e7 ff81      switch_BnFET:	sbrs	flags1, FULL_POWER
0000e8 98c1      		BnFET_off		; Bn off
                 
                 	; reload timer0 with the appropriate value
                 reload_t0_off_cycle:
0000e9 2d42      		mov	i_temp1, tcnt0_power_on
0000ea 594c      		subi	i_temp1, -POWER_RANGE	; adi i_temp1, POWER_RANGE
0000eb 9540      		com	i_temp1			; timer0 increments
0000ec bf42      		out	TCNT0, i_temp1
                 
0000ed c01b      		rjmp	t0_int_exit
                 
                 ; reload timer90 + switch appropriate nFET on
0000ee 2d42      t0_on_cycle:	mov	i_temp1, tcnt0_power_on
0000ef bf42      		out	TCNT0, i_temp1		; reload t0
0000f0 7b7f      		cbr	flags0, (1<<I_OFF_CYCLE) ; PWM state = on cycle (no off cycle)
                 
                 ; switch appropriate nFET on
0000f1 ff74      nFET_on:	sbrs	flags0, C_FET		; is Cn choppered ?
0000f2 c003      		rjmp	test_AnFET_on			; .. no - test An
0000f3 ff80      		sbrs	flags1, POWER_OFF
0000f4 9ac0      		CnFET_on		; Cn on
0000f5 c007      		rjmp	eval_power_state
0000f6 ff75      test_AnFET_on:	sbrs	flags0, A_FET		; is An choppered ?
0000f7 c003      		rjmp	sw_BnFET_on			; .. no - Bn has to be choppered
0000f8 ff80      		sbrs	flags1, POWER_OFF
0000f9 9ac2      		AnFET_on		; An on
0000fa c002      		rjmp	eval_power_state
0000fb ff80      sw_BnFET_on:	sbrs	flags1, POWER_OFF
0000fc 9ac1      		BnFET_on		; Bn on
                 
                 	; evaluate power state
                 eval_power_state:
0000fd 394d      		cpi	i_temp1, MAX_POWER+1
0000fe f418      		brsh	not_full_power
                 	; FULL POWER
0000ff 6082      		sbr	flags1, (1<<FULL_POWER)	; tcnt0_power_on = MAX_POWER means FULL_POWER
000100 7f8e      		cbr	flags1, (1<<POWER_OFF)
000101 c007      		rjmp	t0_int_exit
000102 3f46      not_full_power:	cpi	i_temp1, NO_POWER
000103 f018      		brlo	neither_full_nor_off
                 	; POWER OFF
000104 7f8d      		cbr	flags1, (1<<FULL_POWER)	; tcnt0_power_on = NO_POWER means power off
000105 6081      		sbr	flags1, (1<<POWER_OFF)
000106 c002      		rjmp	t0_int_exit
                 neither_full_nor_off:
000107 7f8d      		cbr	flags1, (1<<FULL_POWER)	; tcnt0_power_on = MAX_POWER means FULL_POWER
000108 7f8e      		cbr	flags1, (1<<POWER_OFF)
                 
000109 fd93      t0_int_exit:	sbrc	flags2, POFF_CYCLE
00010a 6081      		sbr	flags1, (1<<POWER_OFF)
00010b be1f      		out	SREG, i_sreg
00010c 9518      		reti
                 ;-----bko-----------------------------------------------------------------
                 .if UART_CONTROL == 1
                 .endif	; UART_CONTROL == 1
                 ;-----bko-----------------------------------------------------------------
                 ; beeper: timer0 is set to 1µs/count
00010d ec38      beep_f1:	ldi	temp4, 200
00010e e510      		ldi	temp2, 80
00010f c009      		rjmp	beep
                 
000110 eb34      beep_f2:	ldi	temp4, 180
000111 e614      		ldi	temp2, 100
000112 c006      		rjmp	beep
                 
000113 ea30      beep_f3:	ldi	temp4, 160
000114 e718      		ldi	temp2, 120
000115 c003      		rjmp	beep
                 
000116 e634      beep_f4:	ldi	temp4, 100
000117 ec18      		ldi	temp2, 200
000118 c000      		rjmp	beep
                 
000119 2700      beep:		clr	temp1
00011a bf02      		out	TCNT0, temp1
00011b 9a94      		BpFET_on		; BpFET on
00011c 9ac2      		AnFET_on		; CnFET on
00011d b702      beep_BpCn10:	in	temp1, TCNT0
00011e 3200      		cpi	temp1, 32		; 32µs on
00011f f7e9      		brne	beep_BpCn10
000120 9894      		BpFET_off		; BpFET off
000121 98c2      		AnFET_off		; CnFET off
000122 e028      		ldi	temp3, 8		; 2040µs off
000123 2700      beep_BpCn12:	clr	temp1
000124 bf02      		out	TCNT0, temp1
000125 b702      beep_BpCn13:	in	temp1, TCNT0
000126 1703      		cp	temp1, temp4
000127 f7e9      		brne	beep_BpCn13
000128 952a      		dec	temp3
000129 f7c9      		brne	beep_BpCn12
00012a 951a      		dec	temp2
00012b f769      		brne	beep
00012c 9508      		ret
                 
00012d e01f      wait30ms:	ldi	temp2, 15
00012e e028      beep_BpCn20:	ldi	temp3, 8
00012f 2700      beep_BpCn21:	clr	temp1
000130 bf02      		out	TCNT0, temp1
000131 b702      beep_BpCn22:	in	temp1, TCNT0
000132 3f0f      		cpi	temp1, 255
000133 f7e9      		brne	beep_BpCn22
000134 952a      		dec	temp3
000135 f7c9      		brne	beep_BpCn21
000136 951a      		dec	temp2
000137 f7b1      		brne	beep_BpCn20
000138 9508      		ret
                 
                 	; 128 periods = 261ms silence
000139 e810      wait260ms:	ldi	temp2, 128
00013a e028      beep2_BpCn20:	ldi	temp3, 8
00013b 2700      beep2_BpCn21:	clr	temp1
00013c bf02      		out	TCNT0, temp1
00013d b702      beep2_BpCn22:	in	temp1, TCNT0
00013e 3f0f      		cpi	temp1, 255
00013f f7e9      		brne	beep2_BpCn22
000140 952a      		dec	temp3
000141 f7c9      		brne	beep2_BpCn21
000142 951a      		dec	temp2
000143 f7b1      		brne	beep2_BpCn20
000144 9508      		ret
                 ;-----bko-----------------------------------------------------------------
000145 e030      tcnt1_to_temp:	ldi	temp4, EXT0_DIS		; disable ext0int
000146 bf3b      		out	GIMSK, temp4
000147 e030      		ldi	temp4, T1STOP		; stop timer1
000148 bd3e      		out	TCCR1B, temp4
000149 e032      		ldi	temp4, T1CK8		; preload temp with restart timer1
00014a b50c      		in	temp1, TCNT1L		;  - the preload cycle is needed to complete stop operation
00014b b51d      		in	temp2, TCNT1H
00014c bd3e      		out	TCCR1B, temp4
00014d 9508      		ret				; !!! ext0int stays disabled - must be enabled again by caller
                 	; there seems to be only one TEMP register in the AVR
                 	; if the ext0int interrupt falls between readad LOW value while HIGH value is captured in TEMP and
                 	; read HIGH value, TEMP register is changed in ext0int routine
                 ;-----bko-----------------------------------------------------------------
                 .if RC_PULS == 1
                 evaluate_rc_puls:
00014e 7e8f      		cbr	flags1, (1<<EVAL_RC_PULS)
00014f ff83      		sbrs	flags1, RC_PULS_UPDATED
000150 c015      		rjmp	eval_rc_p90
000151 9100 0079 		lds	temp1, new_rcpuls_l
000153 9110 007a 		lds	temp2, new_rcpuls_h
000155 7f87      		cbr	flags1, (1<<RC_PULS_UPDATED) ; rc impuls value is read out
000156 5e08      		subi	temp1, low  (MIN_RC_PULS)
000157 4013      		sbci	temp2, high (MIN_RC_PULS)
000158 f410      		brcc	eval_rc_p00
000159 2700      		clr	temp1
00015a 2711      		clr	temp2
00015b 9516      eval_rc_p00:	lsr	temp2
00015c 9507      		ror	temp1
00015d 9516      		lsr	temp2
00015e 9507      		ror	temp1
                 
                 .if RANGE533MS == 1	; full rc-pulse-range is lower than 800ms - make 533ms range
                 .else
                 	; actual (0-800) -> (0-200)
00015f 9516      		lsr	temp2		; (0-200) -> (0-100)
000160 9507      		ror	temp1
                 
                 .endif	; RANGE533MS == 1
                 
000161 2f20      		mov	temp3, temp1		
000162 5604      		subi	temp1, POWER_RANGE
000163 f008      		brcs	eval_rc_p10
000164 e624      		ldi	temp3, POWER_RANGE
000165 2ff2      eval_rc_p10:	mov	ZH, temp3
000166 9508      eval_rc_p90:	ret
                 .endif	; RC_PULS == 1
                 ;-----bko-----------------------------------------------------------------
000167 778f      evaluate_uart:	cbr	flags1, (1<<EVAL_UART)
                 .if UART_CONTROL == 1
                 .endif	; UART_CONTROL == 1
000168 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 evaluate_sys_state:
000169 7d8f      		cbr	flags1, (1<<EVAL_SYS_STATE)
00016a ff77      		sbrs	flags0, T1OVFL_FLAG
00016b c017      		rjmp	eval_sys_s99
                 
                 	; do it not more often as every 65µs
00016c 777f      		cbr	flags0, (1<<T1OVFL_FLAG)
                 
                 	; control current
00016d ff72      eval_sys_i:	sbrs	flags0, I_pFET_HIGH
00016e c006      		rjmp	eval_sys_i_ok
00016f 7f7b      		cbr	flags0, (1<<I_pFET_HIGH)
000170 2d4c      		mov	i_temp1, current_err
000171 3043      		cpi	i_temp1, CURRENT_ERR_MAX
000172 f490      		brcc	panic_exit
000173 94c3      		inc	current_err
000174 c003      		rjmp	eval_sys_ub
                 
000175 20cc      eval_sys_i_ok:	tst	current_err
000176 f009      		breq	eval_sys_ub
000177 94ca      		dec	current_err
                 
                 	; control voltage
000178 ff71      eval_sys_ub:	sbrs	flags0, UB_LOW
000179 c006      		rjmp	eval_sys_ub_ok
00017a 7f7d      		cbr	flags0, (1<<UB_LOW)
00017b 2d4d      		mov	i_temp1, sys_control
00017c 3644      		cpi	i_temp1, POWER_RANGE
00017d f428      		brcc	eval_sys_s99
00017e 94d3      		inc	sys_control
00017f c003      		rjmp	eval_sys_s99
                 
000180 20dd      eval_sys_ub_ok:	tst	sys_control
000181 f009      		breq	eval_sys_s99
000182 94da      		dec	sys_control
                 		
000183 d117      eval_sys_s99:	rcall	set_new_duty
000184 9508      		ret
                 
                 panic_exit:	; !!!!!! OVERCURRENT !!!!!!!!
000185 94f8      		cli
000186 ce8f      		rjmp	reset
                 ;-----bko-----------------------------------------------------------------
000187 7b8f      evaluate_rpm:	cbr	flags1, (1<<EVAL_RPM)
000188 9120 006c 		lds	temp3, rpm_x
00018a 9110 006b 		lds	temp2, rpm_h
                 
00018c 9100 006a 		lds	temp1, rpm_l	; subtract 1/256
00018e 1b01      		sub	temp1, temp2
00018f 9300 006a 		sts	rpm_l, temp1
000191 9100 006b 		lds	temp1, rpm_h
000193 0b02      		sbc	temp1, temp3
000194 9300 006b 		sts	rpm_h, temp1
000196 9100 006c 		lds	temp1, rpm_x
000198 4000      		sbci	temp1, 0
000199 9300 006c 		sts	rpm_x, temp1
                 
00019b 9120 0069 		lds	temp3, timing_acc_x
00019d 9110 0068 		lds	temp2, timing_acc_h
00019f 9100 0067 		lds	temp1, timing_acc_l
0001a1 9526      		lsr	temp3		; make one complete commutation cycle
0001a2 9517      		ror	temp2
0001a3 9507      		ror	temp1
0001a4 9526      		lsr	temp3
0001a5 9517      		ror	temp2
0001a6 9507      		ror	temp1
                 	; temp3 is zero now - for sure !!
0001a7 9320 0069 		sts	timing_acc_x, temp3
0001a9 9320 0068 		sts	timing_acc_h, temp3
0001ab 9320 0067 		sts	timing_acc_l, temp3
                 	; and add the result as 1/256
0001ad 9120 006a 		lds	temp3, rpm_l
0001af 0f20      		add	temp3, temp1
0001b0 9320 006a 		sts	rpm_l, temp3
0001b2 9120 006b 		lds	temp3, rpm_h
0001b4 1f21      		adc	temp3, temp2
0001b5 9320 006b 		sts	rpm_h, temp3
0001b7 e000      		ldi	temp1, 0
0001b8 9120 006c 		lds	temp3, rpm_x
0001ba 1f20      		adc	temp3, temp1
0001bb 9320 006c 		sts	rpm_x, temp3
                 
0001bd 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 set_all_timings:
0001be e8c8      		ldi	YL, low  (timeoutSTART)
0001bf e0dd      		ldi	YH, high (timeoutSTART)
0001c0 93c0 0071 		sts	wt_OCT1_tot_l, YL
0001c2 93d0 0072 		sts	wt_OCT1_tot_h, YH
0001c4 ef2f      		ldi	temp3, 0xff
0001c5 e13f      		ldi	temp4, 0x1f
0001c6 9320 006d 		sts	wt_comp_scan_l, temp3
0001c8 9330 006e 		sts	wt_comp_scan_h, temp4
0001ca 9320 006f 		sts	com_timing_l, temp3
0001cc 9330 0070 		sts	com_timing_h, temp4
                 
0001ce e0e1      set_timing_v:	ldi	ZL, 0x01
0001cf 93e0 0066 		sts	timing_x, ZL
0001d1 ef3f      		ldi	temp4, 0xff
0001d2 9330 0065 		sts	timing_h, temp4
0001d4 ef2f      		ldi	temp3, 0xff
0001d5 9320 0064 		sts	timing_l, temp3
                 
0001d7 9508      		ret
                 ;-----bko-----------------------------------------------------------------
0001d8 df6c      update_timing:	rcall	tcnt1_to_temp
0001d9 9300 0060 		sts	tcnt1_sav_l, temp1
0001db 9310 0061 		sts	tcnt1_sav_h, temp2
0001dd 0f0c      		add	temp1, YL
0001de 1f1d      		adc	temp2, YH
0001df e035      		ldi	temp4, (1<<TOIE1)+(1<<TOIE0)
0001e0 bf39      		out	TIMSK, temp4
0001e1 bd1b      		out	OCR1AH, temp2
0001e2 bd0a      		out	OCR1AL, temp1
0001e3 6071      		sbr	flags0, (1<<OCT1_PENDING)
0001e4 e135      		ldi	temp4, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; enable interrupt again
0001e5 bf39      		out	TIMSK, temp4
0001e6 e430      		ldi	temp4, EXT0_EN		; ext0int enable
0001e7 bf3b      		out	GIMSK, temp4		; enable ext0int
                 
                 	; calculate next waiting times - timing(-l-h-x) holds the time of 4 commutations
0001e8 9100 0064 		lds	temp1, timing_l
0001ea 9110 0065 		lds	temp2, timing_h
0001ec 91e0 0066 		lds	ZL, timing_x
                 
0001ee 9300 0073 		sts	zero_wt_l, temp1	; save for zero crossing timeout
0001f0 9310 0074 		sts	zero_wt_h, temp2
0001f2 23ee      		tst	ZL
0001f3 f029      		breq	update_t00
0001f4 ef3f      		ldi	temp4, 0xff
0001f5 9330 0073 		sts	zero_wt_l, temp4	; save for zero crossing timeout
0001f7 9330 0074 		sts	zero_wt_h, temp4
                 update_t00:
0001f9 95e6      		lsr	ZL			; build a quarter
0001fa 9517      		ror	temp2
0001fb 9507      		ror	temp1
                 
0001fc 95e6      		lsr	ZL
0001fd 9517      		ror	temp2
0001fe 9507      		ror	temp1
0001ff 9120 0064 		lds	temp3, timing_l		; .. and subtract from timing
000201 9130 0065 		lds	temp4, timing_h
000203 91e0 0066 		lds	ZL, timing_x
000205 1b20      		sub	temp3, temp1
000206 0b31      		sbc	temp4, temp2
000207 40e0      		sbci	ZL, 0
                 
000208 9100 0060 		lds	temp1, tcnt1_sav_l	; calculate this commutation time
00020a 9110 0061 		lds	temp2, tcnt1_sav_h
00020c 91c0 0062 		lds	YL, last_tcnt1_l
00020e 91d0 0063 		lds	YH, last_tcnt1_h
000210 9300 0062 		sts	last_tcnt1_l, temp1
000212 9310 0063 		sts	last_tcnt1_h, temp2
000214 1b0c      		sub	temp1, YL
000215 0b1d      		sbc	temp2, YH
000216 9300 0075 		sts	last_com_l, temp1
000218 9310 0076 		sts	last_com_h, temp2
                 
00021a 0f20      		add	temp3, temp1		; .. and add to timing
00021b 1f31      		adc	temp4, temp2
00021c e010      		ldi	temp2, 0
00021d 1fe1      		adc	ZL, temp2
                 
                 	; limit RPM to 120.000
00021e 23ee      		tst	ZL
00021f f461      		brne	update_t90
000220 2333      		tst	temp4
000221 f021      		breq	update_t10
000222 3031      		cpi	temp4, 1
000223 f441      		brne	update_t90
000224 342c      		cpi	temp3, 0x4c		; 0x14c = 120.000 RPM
000225 f430      		brcc	update_t90
                 	; set RPM to 120.000
000226 e031      update_t10:	ldi	temp4, 0x01
000227 e42c      		ldi	temp3, 0x4c
000228 20ff      		tst	run_control 
000229 f411      		brne	update_t90		; just active
00022a ef0f      		ldi	temp1, 0xff		; not active - reactivate
00022b 2ef0      		mov	run_control, temp1
                 
00022c 9320 0064 update_t90:	sts	timing_l, temp3
00022e 9330 0065 		sts	timing_h, temp4
000230 93e0 0066 		sts	timing_x, ZL
000232 30e2      		cpi	ZL, 2		; limit range to 0x1ffff
000233 f008      		brcs	update_t99
000234 df99      		rcall	set_timing_v
                 
000235 9100 0067 update_t99:	lds	temp1, timing_acc_l
000237 0f02      		add	temp1, temp3
000238 9300 0067 		sts	timing_acc_l, temp1
00023a 9100 0068 		lds	temp1, timing_acc_h
00023c 1f03      		adc	temp1, temp4
00023d 9300 0068 		sts	timing_acc_h, temp1
00023f 9100 0069 		lds	temp1, timing_acc_x
000241 1f0e      		adc	temp1, ZL
000242 9300 0069 		sts	timing_acc_x, temp1
                 
000244 95e6      		lsr	ZL			; a 16th is the next wait before scan
000245 9537      		ror	temp4
000246 9527      		ror	temp3
000247 95e6      		lsr	ZL
000248 9537      		ror	temp4
000249 9527      		ror	temp3
00024a 95e6      		lsr	ZL
00024b 9537      		ror	temp4
00024c 9527      		ror	temp3
00024d 95e6      		lsr	ZL
00024e 9537      		ror	temp4
00024f 9527      		ror	temp3
000250 9320 006d 		sts	wt_comp_scan_l, temp3
000252 9330 006e 		sts	wt_comp_scan_h, temp4
                 
                 	; use the same value for commutation timing (15°)
000254 9320 006f 		sts	com_timing_l, temp3
000256 9330 0070 		sts	com_timing_h, temp4
                 
000258 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 calc_next_timing:
000259 91c0 006d 		lds	YL, wt_comp_scan_l	; holds wait-before-scan value
00025b 91d0 006e 		lds	YH, wt_comp_scan_h
00025d df7a      		rcall	update_timing
                 
00025e 9508      		ret
                 
00025f fd70      wait_OCT1_tot:	sbrc	flags0, OCT1_PENDING
000260 cffe      		rjmp	wait_OCT1_tot
                 
                 set_OCT1_tot:
                 ;		cbi	ADCSRA, ADEN		; switch to comparator multiplexed
                 ;		in	temp1, SFIOR
                 ;		ori	temp1, (1<<ACME)
                 ;		out	SFIOR, temp1
                 
000261 91d0 0074 		lds	YH, zero_wt_h
000263 91c0 0073 		lds	YL, zero_wt_l
000265 dedf      		rcall	tcnt1_to_temp
000266 0f0c      		add	temp1, YL
000267 1f1d      		adc	temp2, YH
000268 e035      		ldi	temp4, (1<<TOIE1)+(1<<TOIE0)
000269 bf39      		out	TIMSK, temp4
00026a bd1b      		out	OCR1AH, temp2
00026b bd0a      		out	OCR1AL, temp1
00026c 6071      		sbr	flags0, (1<<OCT1_PENDING)
00026d e135      		ldi	temp4, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
00026e bf39      		out	TIMSK, temp4
00026f e430      		ldi	temp4, EXT0_EN		; ext0int enable
000270 bf3b      		out	GIMSK, temp4		; enable ext0int
                 
000271 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 wait_OCT1_before_switch:
000272 ded2      		rcall	tcnt1_to_temp
000273 91c0 006f 		lds	YL, com_timing_l
000275 91d0 0070 		lds	YH, com_timing_h
000277 0f0c      		add	temp1, YL
000278 1f1d      		adc	temp2, YH
000279 e025      		ldi	temp3, (1<<TOIE1)+(1<<TOIE0)
00027a bf29      		out	TIMSK, temp3
00027b bd1b      		out	OCR1AH, temp2
00027c bd0a      		out	OCR1AL, temp1
00027d 6071      		sbr	flags0, (1<<OCT1_PENDING)
00027e e125      		ldi	temp3, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0)
00027f bf29      		out	TIMSK, temp3
000280 e430      		ldi	temp4, EXT0_EN		; ext0int enable
000281 bf3b      		out	GIMSK, temp4		; enable ext0int
                 
                 	; don't waste time while waiting - do some controls, if indicated
                 .if RC_PULS == 1
000282 fd84      		sbrc	flags1, EVAL_RC_PULS
000283 deca      		rcall	evaluate_rc_puls
                 .endif
000284 fd85      		sbrc	flags1, EVAL_SYS_STATE
000285 dee3      		rcall	evaluate_sys_state
                 
                 .if UART_CONTROL == 1
                 .endif
000286 fd86      		sbrc	flags1, EVAL_RPM
000287 deff      		rcall	evaluate_rpm
                 
000288 fd70      OCT1_wait:	sbrc	flags0, OCT1_PENDING
000289 cffe      		rjmp	OCT1_wait
00028a 9508      		ret
                 ;-----bko-----------------------------------------------------------------
00028b 91c0 0071 start_timeout:	lds	YL, wt_OCT1_tot_l
00028d 91d0 0072 		lds	YH, wt_OCT1_tot_h
00028f df48      		rcall	update_timing
                 
000290 b50c      		in	temp1, TCNT1L
000291 700f      		andi	temp1, 0x0f
000292 1bd0      		sub	YH, temp1
000293 38dc      		cpi	YH, high (timeoutMIN)
000294 f408      		brcc	set_tot2
000295 e0dd      		ldi	YH, high (timeoutSTART)		
                 set_tot2:
000296 93d0 0072 		sts	wt_OCT1_tot_h, YH
                 
000298 d03b      		rcall	sync_with_poweron	; wait at least 100+ microseconds
000299 d03a      		rcall	sync_with_poweron	; for demagnetisation - one sync may be added
                 
00029a 9508      		ret
                 ;-----bko-----------------------------------------------------------------
00029b 2f0f      set_new_duty:	mov	temp1, ZH
00029c 190d      		sub	temp1, sys_control
00029d f408      		brcc	set_new_duty10
00029e e009      		ldi	temp1, MIN_DUTY-1
00029f 9110 0066 set_new_duty10:	lds	temp2, timing_x
0002a1 2311      		tst	temp2
0002a2 f421      		brne	set_new_duty12
0002a3 9110 0065 		lds	temp2, timing_h	; get actual RPM reference high
0002a5 3410      		cpi	temp2, PWR_RANGE1	; lower range1 ?
0002a6 f038      		brcs	set_new_duty20		; on carry - test next range
0002a7 6091      set_new_duty12:	sbr	flags2, (1<<RPM_RANGE1)
0002a8 6092      		sbr	flags2, (1<<RPM_RANGE2)
0002a9 e119      		ldi	temp2, PWR_MAX_RPM1	; higher than range1 power max ?
0002aa 1701      		cp	temp1, temp2
0002ab f098      		brcs	set_new_duty31		; on carry - not higher, no restriction
0002ac 2f01      		mov	temp1, temp2		; low (range1) RPM - set PWR_MAX_RPM1
0002ad c011      		rjmp	set_new_duty31
0002ae ff95      set_new_duty20:	sbrs	flags2, STARTUP
0002af c005      		rjmp	set_new_duty25
0002b0 e02f      		ldi	temp3, PWR_MAX_STARTUP	; limit power in startup phase
0002b1 1702      		cp	temp1, temp3
0002b2 f010      		brcs	set_new_duty25		; on carry - not higher, test range 2
0002b3 2f02      		mov	temp1, temp3		; set PWR_MAX_STARTUP limit
0002b4 c00a      		rjmp	set_new_duty31
0002b5 3210      set_new_duty25:	cpi	temp2, PWR_RANGE2	; lower range2 ?
0002b6 f038      		brcs	set_new_duty30		; on carry - not lower, no restriction
0002b7 7f9e      		cbr	flags2, (1<<RPM_RANGE1)
0002b8 6092      		sbr	flags2, (1<<RPM_RANGE2)
0002b9 e312      		ldi	temp2, PWR_MAX_RPM2	; higher than range2 power max ?
0002ba 1701      		cp	temp1, temp2
0002bb f018      		brcs	set_new_duty31		; on carry - not higher, no restriction
0002bc 2f01      		mov	temp1, temp2		; low (range2) RPM - set PWR_MAX_RPM2
0002bd c001      		rjmp	set_new_duty31
0002be 7f9c      set_new_duty30:	cbr	flags2, (1<<RPM_RANGE1)+(1<<RPM_RANGE2)
0002bf 9500      set_new_duty31:	com	temp1			; down-count to up-count (T0)
0002c0 2e60      		mov	tcnt0_pwron_next, temp1	; save in next
                 	; tcnt0_power_on is updated to tcnt0_pwron_next in acceptable steps
0002c1 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 .if UART_CONTROL == 1
                 .endif		; UART_CONTROL == 1
                 ;-----bko-----------------------------------------------------------------
                 switch_power_off:
0002c2 e0f9      		ldi	ZH, MIN_DUTY-1		; ZH is new_duty
0002c3 ef06      		ldi	temp1, NO_POWER		; lowest tcnt0_power_on value
0002c4 2e20      		mov	tcnt0_power_on, temp1
0002c5 2e60      		mov	tcnt0_pwron_next, temp1
0002c6 e000      		ldi	temp1, INIT_PB		; all off
0002c7 bb08      		out	PORTB, temp1
0002c8 e000      		ldi	temp1, INIT_PD		; all off
0002c9 bb02      		out	PORTD, temp1
0002ca e001      		ldi	temp1, CHANGE_TIMEOUT	; reset change-timeout
0002cb 2e30      		mov	tcnt0_change_tot, temp1
0002cc 6081      		sbr	flags1, (1<<POWER_OFF)	; disable power on
0002cd 7f97      		cbr	flags2, (1<<POFF_CYCLE)
0002ce 6290      		sbr	flags2, (1<<STARTUP)
0002cf 9508      		ret				; motor is off
                 ;-----bko-----------------------------------------------------------------
0002d0 e004      wait_if_spike:	ldi	temp1, 4
0002d1 950a      wait_if_spike2:	dec	temp1
0002d2 f7f1      		brne	wait_if_spike2
0002d3 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 sync_with_poweron:
0002d4 fd76      		sbrc	flags0, I_OFF_CYCLE	; first wait for power on
0002d5 cffe      		rjmp	sync_with_poweron
                 wait_for_poweroff:
0002d6 ff76      		sbrs	flags0, I_OFF_CYCLE	; now wait for power off
0002d7 cffe      		rjmp	wait_for_poweroff
                 .if RC_PULS == 0
                 .endif	; RC_PULS == 0
0002d8 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 motor_brake:
                 .if MOT_BRAKE == 1
                 .if RC_PULS == 1
                 .endif
                 .if RC_PULS == 1
                 .endif
                 .endif	; MOT_BRAKE == 1
0002d9 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 ; **** startup loop ****
0002da dfe7      init_startup:	rcall	switch_power_off
0002db dffd      		rcall	motor_brake
                 wait_for_power_on:
                 
                 .if RC_PULS == 1
0002dc de71      		rcall	evaluate_rc_puls
                 .endif
                 .if UART_CONTROL == 1
                 .endif
0002dd 30fa      		cpi	ZH, MIN_DUTY
0002de f3e8      		brcs	wait_for_power_on
                 
0002df e00a      		ldi	temp1, PWR_STARTUP	; begin startup with low power
0002e0 9500      		com	temp1
0002e1 2e60      		mov	tcnt0_pwron_next, temp1
                 
0002e2 9837      		cbi	ADCSRA, ADEN		; switch to comparator multiplexed
0002e3 b700      		in	temp1, SFIOR
0002e4 6008      		sbr	temp1, (1<<ACME)
0002e5 bf00      		out	SFIOR, temp1
                 
0002e6 2733      		clr	temp4
0002e7 e000      		ldi	temp1, INIT_PB		; all off
0002e8 bb08      		out	PORTB, temp1
0002e9 e000      		ldi	temp1, INIT_PD		; all off
0002ea bb02      		out	PORTD, temp1
0002eb e10b      		ldi	temp1, 27		; wait about 5mikosec
0002ec 950a      FETs_off_wt:	dec	temp1
0002ed f7f1      		brne	FETs_off_wt
                 
0002ee d14b      		rcall	com5com6
0002ef d152      		rcall	com6com1
                 
0002f0 7f9b      		cbr	flags2, (1<<SCAN_TIMEOUT)
0002f1 e000      		ldi	temp1, 0
0002f2 9300 007c 		sts	goodies, temp1
                 
0002f4 e208      		ldi	temp1, 40	; x 65msec
0002f5 2ee0      		mov	t1_timeout, temp1
                 
0002f6 dec7      		rcall	set_all_timings
                 
0002f7 df93      		rcall	start_timeout
                 
                 	; fall through start1
                 
                 ;-----bko-----------------------------------------------------------------
                 ; **** start control loop ****
                 
                 ; state 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
0002f8 ff94      start1:		sbrs	flags2, COMP_SAVE	; high ?
0002f9 c011      		rjmp	start1_2		; .. no - loop, while high
                 
0002fa fd70      start1_0:	sbrc	flags0, OCT1_PENDING
0002fb c002      		rjmp	start1_1
0002fc 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
0002fd c014      		rjmp	start1_9
0002fe dfd5      start1_1:	rcall	sync_with_poweron
                 
0002ff fd94      		sbrc	flags2, COMP_SAVE	; high ?
000300 cff9      		rjmp	start1_0		; .. no - loop, while high
                 
                 ; do the special 120° switch
000301 e000      		ldi	temp1, 0
000302 9300 007c 		sts	goodies, temp1
000304 d0f9      		rcall	com1com2
000305 d102      		rcall	com2com3
000306 d114      		rcall	com3com4
                 .if RC_PULS == 1
000307 de46      		rcall	evaluate_rc_puls
                 .endif
000308 de5e      		rcall	evaluate_uart
000309 df81      		rcall	start_timeout
00030a c031      		rjmp	start4
                 	
00030b fd70      start1_2:	sbrc	flags0, OCT1_PENDING
00030c c002      		rjmp	start1_3
00030d 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
00030e c003      		rjmp	start1_9
00030f dfc4      start1_3:	rcall	sync_with_poweron
000310 ff94      		sbrs	flags2, COMP_SAVE	; high ?
000311 cff9      		rjmp	start1_2		; .. no - loop, while low
                 
                 start1_9:
000312 d0eb      		rcall	com1com2
000313 df77      		rcall	start_timeout
                 
                 ; state 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
                 
000314 fd94      start2:		sbrc	flags2, COMP_SAVE
000315 c008      		rjmp	start2_2
                 
000316 fd70      start2_0:	sbrc	flags0, OCT1_PENDING
000317 c002      		rjmp	start2_1
000318 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000319 c00b      		rjmp	start2_9
00031a dfb9      start2_1:	rcall	sync_with_poweron
00031b ff94      		sbrs	flags2, COMP_SAVE
00031c cff9      		rjmp	start2_0
00031d c007      		rjmp	start2_9
                 
00031e fd70      start2_2:	sbrc	flags0, OCT1_PENDING
00031f c002      		rjmp	start2_3
000320 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000321 c003      		rjmp	start2_9
000322 dfb1      start2_3:	rcall	sync_with_poweron
000323 fd94      		sbrc	flags2, COMP_SAVE
000324 cff9      		rjmp	start2_2
                 
                 start2_9:
000325 d0e2      		rcall	com2com3
                 .if RC_PULS == 1
000326 de27      		rcall	evaluate_rc_puls
                 .endif
000327 df63      		rcall	start_timeout
                 
                 ; state 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 
000328 ff94      start3:		sbrs	flags2, COMP_SAVE
000329 c008      		rjmp	start3_2
                 
00032a fd70      start3_0:	sbrc	flags0, OCT1_PENDING
00032b c002      		rjmp	start3_1
00032c 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
00032d c00b      		rjmp	start3_9
00032e dfa5      start3_1:	rcall	sync_with_poweron
00032f fd94      		sbrc	flags2, COMP_SAVE
000330 cff9      		rjmp	start3_0
000331 c007      		rjmp	start3_9
                 
000332 fd70      start3_2:	sbrc	flags0, OCT1_PENDING
000333 c002      		rjmp	start3_3
000334 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000335 c003      		rjmp	start3_9
000336 df9d      start3_3:	rcall	sync_with_poweron
000337 ff94      		sbrs	flags2, COMP_SAVE
000338 cff9      		rjmp	start3_2
                 
                 start3_9:
000339 d0e1      		rcall	com3com4
00033a de2c      		rcall	evaluate_uart
00033b df4f      		rcall	start_timeout
                 
                 ; state 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
                 
00033c fd94      start4:		sbrc	flags2, COMP_SAVE
00033d c008      		rjmp	start4_2
                 
00033e fd70      start4_0:	sbrc	flags0, OCT1_PENDING
00033f c002      		rjmp	start4_1
000340 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000341 c00b      		rjmp	start4_9
000342 df91      start4_1:	rcall	sync_with_poweron
000343 ff94      		sbrs	flags2, COMP_SAVE
000344 cff9      		rjmp	start4_0
000345 c007      		rjmp	start4_9
                 
000346 fd70      start4_2:	sbrc	flags0, OCT1_PENDING
000347 c002      		rjmp	start4_3
000348 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000349 c003      		rjmp	start4_9
00034a df89      start4_3:	rcall	sync_with_poweron
00034b fd94      		sbrc	flags2, COMP_SAVE
00034c cff9      		rjmp	start4_2
                 
                 start4_9:
00034d d0d7      		rcall	com4com5
00034e df3c      		rcall	start_timeout
                 
                 
                 ; state 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
                 
                 
00034f ff94      start5:		sbrs	flags2, COMP_SAVE
000350 c008      		rjmp	start5_2
                 
000351 fd70      start5_0:	sbrc	flags0, OCT1_PENDING
000352 c002      		rjmp	start5_1
000353 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000354 c00b      		rjmp	start5_9
000355 df7e      start5_1:	rcall	sync_with_poweron
000356 fd94      		sbrc	flags2, COMP_SAVE
000357 cff9      		rjmp	start5_0
000358 c007      		rjmp	start5_9
                 
000359 fd70      start5_2:	sbrc	flags0, OCT1_PENDING
00035a c002      		rjmp	start5_3
00035b 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
00035c c003      		rjmp	start5_9
00035d df76      start5_3:	rcall	sync_with_poweron
00035e ff94      		sbrs	flags2, COMP_SAVE
00035f cff9      		rjmp	start5_2
                 
                 start5_9:
000360 d0d9      		rcall	com5com6
000361 de07      		rcall	evaluate_sys_state
000362 df28      		rcall	start_timeout
                 
                 ; state 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
                 
000363 fd94      start6:		sbrc	flags2, COMP_SAVE
000364 c008      		rjmp	start6_2
                 
000365 fd70      start6_0:	sbrc	flags0, OCT1_PENDING
000366 c002      		rjmp	start6_1
000367 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000368 c00b      		rjmp	start6_9
000369 df6a      start6_1:	rcall	sync_with_poweron
00036a ff94      		sbrs	flags2, COMP_SAVE
00036b cff9      		rjmp	start6_0
00036c c007      		rjmp	start6_9
                 
00036d fd70      start6_2:	sbrc	flags0, OCT1_PENDING
00036e c002      		rjmp	start6_3
00036f 6094      		sbr	flags2, (1<<SCAN_TIMEOUT)
000370 c003      		rjmp	start6_9
000371 df62      start6_3:	rcall	sync_with_poweron
000372 fd94      		sbrc	flags2, COMP_SAVE
000373 cff9      		rjmp	start6_2
                 
                 start6_9:
000374 d0cd      		rcall	com6com1
                 
000375 2d02      		mov	temp1, tcnt0_power_on
000376 3f06      		cpi	temp1, NO_POWER
000377 f409      		brne	s6_power_ok
000378 cf61      		rjmp	init_startup
                 
                 s6_power_ok:
                 ;	tst	rcpuls_timeout
                 ;		brne	s6_rcp_ok
                 ;		rjmp	restart_control
                 
000379 20ee      s6_rcp_ok:	tst	t1_timeout
00037a f409      		brne	s6_test_rpm
00037b cf5e      		rjmp	init_startup
                 		
00037c 9100 0066 s6_test_rpm:	lds	temp1, timing_x
00037e 2300      		tst	temp1
00037f f421      		brne	s6_goodies
000380 9100 0065 		lds	temp1, timing_h		; get actual RPM reference high
                 ;		cpi	temp1, PWR_RANGE1
000382 3200      		cpi	temp1, PWR_RANGE2
000383 f050      		brcs	s6_run1
                 
000384 9100 007c s6_goodies:	lds	temp1, goodies
000386 fd92      		sbrc	flags2, SCAN_TIMEOUT
000387 2700      		clr	temp1
000388 9503      		inc	temp1
000389 9300 007c 		sts	goodies,  temp1
00038b 7f9b      		cbr	flags2, (1<<SCAN_TIMEOUT)
00038c 330c      		cpi	temp1, ENOUGH_GOODIES
00038d f038      		brcs	s6_start1	
                 
00038e ef0f      s6_run1:	ldi	temp1, 0xff
00038f 2ef0      		mov	run_control, temp1
                 
000390 dec8      		rcall	calc_next_timing
000391 decf      		rcall	set_OCT1_tot
                 
000392 7d9f      		cbr	flags2, (1<<STARTUP)
000393 779f      		cbr	flags2, (1<<GP_FLAG)	; OCT1-timeout
000394 c002      		rjmp	run1			; running state begins
                 
000395 def5      s6_start1:	rcall	start_timeout		; need to be here for a correct temp1=comp_state
000396 cf61      		rjmp	start1			; go back to state 1
                 
                 ;-----bko-----------------------------------------------------------------
                 ; **** running control loop ****
                 
                 ; run 1 = B(p-on) + C(n-choppered) - comparator A evaluated
                 ; out_cA changes from low to high
                 
000397 d056      run1: 		rcall	wait_for_low
000398 ff70      		sbrs	flags0, OCT1_PENDING
000399 c042      		rjmp	run_to_start
00039a d05b      		rcall	wait_for_high
00039b ff70      		sbrs	flags0, OCT1_PENDING
00039c c03f      		rjmp	run_to_start
                 .if RC_PULS == 0
                 .endif	; RC_PULS == 0
00039d 6480      		sbr	flags1, (1<<EVAL_RPM)
00039e ded3      		rcall	wait_OCT1_before_switch
00039f d05e      		rcall	com1com2
0003a0 deb8      		rcall	calc_next_timing
0003a1 debd      		rcall	wait_OCT1_tot
                 .if RC_PULS == 0
                 .endif	; RC_PULS == 0
                 
                 		
                 ; run 2 = A(p-on) + C(n-choppered) - comparator B evaluated
                 ; out_cB changes from high to low
                 
0003a2 d053      run2:		rcall	wait_for_high
0003a3 ff70      		sbrs	flags0, OCT1_PENDING
0003a4 c037      		rjmp	run_to_start
0003a5 d048      		rcall	wait_for_low
0003a6 ff70      		sbrs	flags0, OCT1_PENDING
0003a7 c034      		rjmp	run_to_start
                 .if RC_PULS == 0
                 .endif	; RC_PULS == 0
0003a8 6180      		sbr	flags1, (1<<EVAL_RC_PULS)
0003a9 dec8      		rcall	wait_OCT1_before_switch
0003aa d05d      		rcall	com2com3
0003ab dead      		rcall	calc_next_timing
0003ac deb2      		rcall	wait_OCT1_tot
                 .if RC_PULS == 0
                 .endif	; RC_PULS == 0
                 
                 ; run 3 = A(p-on) + B(n-choppered) - comparator C evaluated
                 ; out_cC changes from low to high
                 
0003ad d040      run3:		rcall	wait_for_low
0003ae ff70      		sbrs	flags0, OCT1_PENDING
0003af c02c      		rjmp	run_to_start
0003b0 d045      		rcall	wait_for_high
0003b1 ff70      		sbrs	flags0, OCT1_PENDING
0003b2 c029      		rjmp	run_to_start
                 .if RC_PULS == 0
                 .endif	; RC_PULS == 0
0003b3 6880      		sbr	flags1, (1<<EVAL_UART)
0003b4 debd      		rcall	wait_OCT1_before_switch
0003b5 d065      		rcall	com3com4
0003b6 dea2      		rcall	calc_next_timing
0003b7 dea7      		rcall	wait_OCT1_tot
                 .if RC_PULS == 0
                 .endif	; RC_PULS == 0
                 
                 ; run 4 = C(p-on) + B(n-choppered) - comparator A evaluated
                 ; out_cA changes from high to low
0003b8 d03d      run4:		rcall	wait_for_high
0003b9 ff70      		sbrs	flags0, OCT1_PENDING
0003ba c021      		rjmp	run_to_start
0003bb d032      		rcall	wait_for_low
0003bc ff70      		sbrs	flags0, OCT1_PENDING
0003bd c01e      		rjmp	run_to_start
                 .if RC_PULS == 0
                 .endif	; RC_PULS == 0
0003be deb3      		rcall	wait_OCT1_before_switch
0003bf d065      		rcall	com4com5
0003c0 de98      		rcall	calc_next_timing
0003c1 de9d      		rcall	wait_OCT1_tot
                 .if RC_PULS == 0
                 .endif	; RC_PULS == 0
                 
                 ; run 5 = C(p-on) + A(n-choppered) - comparator B evaluated
                 ; out_cB changes from low to high
                 
0003c2 d02b      run5:		rcall	wait_for_low
0003c3 ff70      		sbrs	flags0, OCT1_PENDING
0003c4 c017      		rjmp	run_to_start
0003c5 d030      		rcall	wait_for_high
0003c6 ff70      		sbrs	flags0, OCT1_PENDING
0003c7 c014      		rjmp	run_to_start
                 .if RC_PULS == 0
                 .endif	; RC_PULS == 0
0003c8 6280      		sbr	flags1, (1<<EVAL_SYS_STATE)
0003c9 dea8      		rcall	wait_OCT1_before_switch
0003ca d06f      		rcall	com5com6
0003cb de8d      		rcall	calc_next_timing
0003cc de92      		rcall	wait_OCT1_tot
                 .if RC_PULS == 0
                 .endif	; RC_PULS == 0
                 
                 ; run 6 = B(p-on) + A(n-choppered) - comparator C evaluated
                 ; out_cC changes from high to low
                 
0003cd d028      run6:		rcall	wait_for_high
0003ce ff70      		sbrs	flags0, OCT1_PENDING
0003cf c00c      		rjmp	run_to_start
0003d0 d01d      		rcall	wait_for_low
0003d1 ff70      		sbrs	flags0, OCT1_PENDING
0003d2 c009      		rjmp	run_to_start
                 .if RC_PULS == 0
                 .endif	; RC_PULS == 0
0003d3 de9e      		rcall	wait_OCT1_before_switch
0003d4 d06d      		rcall	com6com1
0003d5 de83      		rcall	calc_next_timing
0003d6 de88      		rcall	wait_OCT1_tot
                 
                 ;		tst	rcpuls_timeout
                 ;		breq	restart_control
                 
0003d7 9100 0066 		lds	temp1, timing_x
0003d9 2300      		tst	temp1
0003da f021      		breq	run6_2			; higher than 610 RPM if zero
0003db 6890      		sbr	flags2, (1<<GP_FLAG)	; mark low RPM
0003dc 6290      run_to_start:	sbr	flags2, (1<<STARTUP)
0003dd 7f97      		cbr	flags2, (1<<POFF_CYCLE)
0003de cefd      		rjmp	wait_for_power_on
                 
0003df 7f97      run6_2:		cbr	flags2, (1<<POFF_CYCLE)
0003e0 20ff      		tst	run_control		; only once !
0003e1 f041      		breq	run6_9
0003e2 94fa      		dec	run_control
0003e3 f029      		breq	run6_3			; poweroff if 0
0003e4 2d0f      		mov	temp1, run_control
0003e5 3001      		cpi	temp1, 1		; poweroff if 1
0003e6 f011      		breq	run6_3
0003e7 3002      		cpi	temp1, 2		; poweroff if 2
0003e8 f409      		brne	run6_9
0003e9 6098      run6_3:		sbr	flags2, (1<<POFF_CYCLE)
                 
                 run6_9:
                 .if RC_PULS == 0
                 .endif	; RC_PULS == 0
0003ea cfac      		rjmp	run1			; go back to run 1
                 
                 restart_control:
0003eb 94f8      		cli				; disable all interrupts
0003ec ded5      		rcall	switch_power_off
0003ed cc28      		rjmp	reset
                 
                 
                 ;-----bko-----------------------------------------------------------------
                 ; *** scan comparator utilities ***
                 ; 
0003ee ff70      wait_for_low:	sbrs	flags0, OCT1_PENDING
0003ef 9508      		ret
0003f0 9b45      		sbis	ACSR, ACO		; low ?
0003f1 cffc      		rjmp	wait_for_low		; .. no - loop, while high
0003f2 dedd      		rcall	wait_if_spike		; .. yes - look for a spike
0003f3 9b45      		sbis	ACSR, ACO		; test again
0003f4 cff9      		rjmp	wait_for_low		; .. is high again, was a spike
0003f5 9508      		ret
                 
0003f6 ff70      wait_for_high:	sbrs	flags0, OCT1_PENDING
0003f7 9508      		ret
0003f8 9945      		sbic	ACSR, ACO		; high ?
0003f9 cffc      		rjmp	wait_for_high		; .. no - loop, while low
0003fa ded5      		rcall	wait_if_spike		; .. yes - look for a spike
0003fb 9945      		sbic	ACSR, ACO		; test again
0003fc cff9      		rjmp	wait_for_high		; .. is low again, was a spike
0003fd 9508      		ret
                 ;-----bko-----------------------------------------------------------------
                 ; *** commutation utilities ***
0003fe 9894      com1com2:	BpFET_off		; Bp off
0003ff ff80      		sbrs	flags1, POWER_OFF
000400 9a95      		ApFET_on		; Ap on
000401 e004      		ldi	temp1, mux_b		; set comparator multiplexer to phase B
000402 b907      		out	ADMUX, temp1
000403 9837      		cbi	ADCSRA, ADEN		; disable ADC
000404 b700      		in	temp1, SFIOR
000405 6008      		sbr	temp1, (1<<ACME)	; switch to comparator multiplexed
000406 bf00      		out	SFIOR, temp1
000407 9508      		ret
                 
000408 e104      com2com3:	ldi	temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
000409 bf09      		out	TIMSK, temp1		;  .. only ONE should change these values at the time
00040a 0000      		nop
00040b 7d7f      		cbr	flags0, (1<<A_FET)	; next nFET = BnFET
00040c 7e7f      		cbr	flags0, (1<<C_FET)
00040d fd81      		sbrc	flags1, FULL_POWER
00040e c002      		rjmp	c2_switch
00040f fd76      		sbrc	flags0, I_OFF_CYCLE	; was power off ?
000410 c003      		rjmp	c2_done			; .. yes - futhermore work is done in timer0 interrupt
000411 98c0      c2_switch:	CnFET_off		; Cn off
000412 ff80      		sbrs	flags1, POWER_OFF
000413 9ac1      		BnFET_on		; Bn on
000414 e105      c2_done:	ldi	temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
000415 bf09      		out	TIMSK, temp1
000416 b700      		in	temp1, SFIOR
000417 7f07      		cbr	temp1, (1<<ACME)	; set to AN1
000418 bf00      		out	SFIOR, temp1
000419 9a37      		sbi	ADCSRA, ADEN		; enable ADC
00041a 9508      		ret
                 
00041b 9895      com3com4:	ApFET_off		; Ap off
00041c ff80      		sbrs	flags1, POWER_OFF
00041d 9a93      		CpFET_on		; Cp on
00041e e005      		ldi	temp1, mux_a		; set comparator multiplexer to phase A
00041f b907      		out	ADMUX, temp1
000420 9837      		cbi	ADCSRA, ADEN		; disable ADC
000421 b700      		in	temp1, SFIOR
000422 6008      		sbr	temp1, (1<<ACME)	; switch to comparator multiplexed
000423 bf00      		out	SFIOR, temp1
000424 9508      		ret
                 
000425 e104      com4com5:	ldi	temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
000426 bf09      		out	TIMSK, temp1		;  .. only ONE should change these values at the time
000427 0000      		nop
000428 6270      		sbr	flags0, (1<<A_FET)	; next nFET = AnFET
000429 7e7f      		cbr	flags0, (1<<C_FET)
00042a fd81      		sbrc	flags1, FULL_POWER
00042b c002      		rjmp	c4_switch
00042c fd76      		sbrc	flags0, I_OFF_CYCLE	; was power off ?
00042d c003      		rjmp	c4_done			; .. yes - futhermore work is done in timer0 interrupt
00042e 98c1      c4_switch:	BnFET_off		; Bn off
00042f ff80      		sbrs	flags1, POWER_OFF
000430 9ac2      		AnFET_on		; An on
000431 e105      c4_done:	ldi	temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
000432 bf09      		out	TIMSK, temp1
000433 e004      		ldi	temp1, mux_b		; set comparator multiplexer to phase B
000434 b907      		out	ADMUX, temp1
000435 9837      		cbi	ADCSRA, ADEN		; disable ADC
000436 b700      		in	temp1, SFIOR
000437 6008      		sbr	temp1, (1<<ACME)	; switch to comparator multiplexed
000438 bf00      		out	SFIOR, temp1
000439 9508      		ret
                 
00043a 9893      com5com6:	CpFET_off		; Cp off
00043b ff80      		sbrs	flags1, POWER_OFF
00043c 9a94      		BpFET_on		; Bp on
00043d b700      		in	temp1, SFIOR
00043e 7f07      		cbr	temp1, (1<<ACME)	; set to AN1
00043f bf00      		out	SFIOR, temp1
000440 9a37      		sbi	ADCSRA, ADEN		; enable ADC
000441 9508      		ret
                 
000442 e104      com6com1:	ldi	temp1, (1<<OCIE1A)+(1<<TOIE1) ; stop timer0 interrupt
000443 bf09      		out	TIMSK, temp1		;  .. only ONE should change these values at the time
000444 0000      		nop
000445 7d7f      		cbr	flags0, (1<<A_FET)	; next nFET = CnFET
000446 6170      		sbr	flags0, (1<<C_FET)
000447 fd81      		sbrc	flags1, FULL_POWER
000448 c002      		rjmp	c6_switch
000449 fd76      		sbrc	flags0, I_OFF_CYCLE	; was power off ?
00044a c003      		rjmp	c6_done			; .. yes - futhermore work is done in timer0 interrupt
00044b 98c2      c6_switch:	AnFET_off		; An off
00044c ff80      		sbrs	flags1, POWER_OFF
00044d 9ac0      		CnFET_on		; Cn on
00044e e105      c6_done:	ldi	temp1, (1<<TOIE1)+(1<<OCIE1A)+(1<<TOIE0) ; let timer0 do his work again
00044f bf09      		out	TIMSK, temp1
000450 e005      		ldi	temp1, mux_a		; set comparator multiplexer to phase A
000451 b907      		out	ADMUX, temp1
000452 9837      		cbi	ADCSRA, ADEN		; disable ADC
000453 b700      		in	temp1, SFIOR
000454 6008      		sbr	temp1, (1<<ACME)	; switch to comparator multiplexed
000455 bf00      		out	SFIOR, temp1
000456 9508      		ret
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega8 register use summary:
r0 :   0 r1 :   8 r2 :   7 r3 :   6 r4 :   0 r5 :   0 r6 :   4 r7 :   2 
r8 :   2 r9 :   0 r10:   0 r11:   8 r12:   5 r13:   6 r14:   4 r15:   6 
r16: 215 r17:  54 r18:  53 r19:  48 r20:  38 r21:  19 r22:  12 r23:  58 
r24:  41 r25:  57 r26:   2 r27:   1 r28:  11 r29:  15 r30:  17 r31:   4 
x  :   1 y  :   0 z  :   0 
Registers used: 28 out of 35 (80.0%)

ATmega8 instruction use summary:
.lds  :   0 .sts  :   0 adc   :   9 add   :   6 adiw  :   0 and   :   0 
andi  :   1 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   7 brcs  :  10 breq  :  13 brge  :   0 brhc  :   0 brhs  :   0 
brid  :   0 brie  :   0 brlo  :   4 brlt  :   0 brmi  :   0 brne  :  23 
brpl  :   0 brsh  :   4 brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 
bset  :   0 bst   :   0 cbi   :  16 cbr   :  33 clc   :   0 clh   :   0 
cli   :   3 cln   :   0 clr   :  14 cls   :   0 clt   :   0 clv   :   0 
clz   :   0 com   :   3 cp    :   5 cpc   :   4 cpi   :  25 cpse  :   0 
dec   :  18 eor   :   0 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 
ijmp  :   0 in    :  23 inc   :   5 ld    :   0 ldd   :   0 ldi   : 100 
lds   :  44 lpm   :   0 lsl   :   0 lsr   :  11 mov   :  34 movw  :   0 
mul   :   0 muls  :   0 mulsu :   0 neg   :   0 nop   :  12 or    :   0 
ori   :   0 out   :  67 pop   :   0 push  :   0 rcall : 106 ret   :  29 
reti  :   4 rjmp  : 124 rol   :   0 ror   :  19 sbc   :   5 sbci  :   4 
sbi   :  13 sbic  :   4 sbis  :   3 sbiw  :   0 sbr   :  43 sbrc  :  37 
sbrs  :  48 sec   :   0 seh   :   0 sei   :   2 sen   :   0 ser   :   0 
ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 spm   :   0 
st    :   1 std   :   0 sts   :  49 sub   :   7 subi  :   4 swap  :   0 
tst   :  14 wdr   :   0 
Instructions used: 45 out of 110 (40.9%)

ATmega8 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0008ae   2206     16   2222    8192  27.1%
[.dseg] 0x000060 0x0000e3      0    131    131    1024  12.8%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
